

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Nuoyan Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="本人的一些 LeetCode 刷题笔记，欢迎参考。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 刷题笔记：hot100">
<meta property="og:url" content="https://cny123222.github.io/2026/01/27/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9Ahot100/index.html">
<meta property="og:site_name" content="Nuoyan Chen&#39;s Blog">
<meta property="og:description" content="本人的一些 LeetCode 刷题笔记，欢迎参考。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cny123222.github.io/img/%E7%AE%97%E6%B3%95.png">
<meta property="article:published_time" content="2026-01-27T05:15:03.000Z">
<meta property="article:modified_time" content="2026-02-14T14:39:30.935Z">
<meta property="article:author" content="Nuoyan Chen">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="刷题笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cny123222.github.io/img/%E7%AE%97%E6%B3%95.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>LeetCode 刷题笔记：hot100 - Nuoyan Chen&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"cny123222.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Nuoyan Chen&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/nanjing.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.4)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetCode 刷题笔记：hot100"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Nuoyan Chen
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2026-01-27 13:15" pubdate>
          January 27, 2026 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.8k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          57 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法"
        id="heading-046a899ee7a6ec88d370211a518c9e80" role="tab" data-toggle="collapse" href="#collapse-046a899ee7a6ec88d370211a518c9e80"
        aria-expanded="true"
      >
        算法
        <span class="list-group-count">(25)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-046a899ee7a6ec88d370211a518c9e80"
           role="tabpanel" aria-labelledby="heading-046a899ee7a6ec88d370211a518c9e80">
        
        
          
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2026/01/27/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9Ahot100/" title="LeetCode 刷题笔记：hot100"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">LeetCode 刷题笔记：hot100</span>
        </a>
      
    
      
      
        <a href="/2025/04/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/" title="算法：期中复习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法：期中复习</span>
        </a>
      
    
      
      
        <a href="/2025/04/24/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%9F%E4%B8%AD%E7%9C%9F%E9%A2%98%EF%BC%882024%E6%98%A5%EF%BC%89/" title="算法：期中真题（2024春）"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法：期中真题（2024春）</span>
        </a>
      
    
      
      
        <a href="/2025/06/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="算法：期末复习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法：期末复习</span>
        </a>
      
    
      
      
        <a href="/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%81%AA%E6%98%8E%E4%BA%BA%E7%9A%84%E8%AE%A1%E7%AE%97%E8%89%BA%E6%9C%AF/" title="算法：聪明人的计算艺术"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法：聪明人的计算艺术</span>
        </a>
      
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="NP完全"
        id="heading-2dcc1c7b0e24462144b81fcfb7044f11" role="tab" data-toggle="collapse" href="#collapse-2dcc1c7b0e24462144b81fcfb7044f11"
        aria-expanded="false"
      >
        NP完全
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-2dcc1c7b0e24462144b81fcfb7044f11"
           role="tabpanel" aria-labelledby="heading-2dcc1c7b0e24462144b81fcfb7044f11">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/05/13/NP-%E5%AE%8C%E5%85%A8-1-%EF%BC%9AP,%20NP%20%E4%B8%8E%20NP%20%E5%AE%8C%E5%85%A8/" title="NP 完全(1)：P, NP 与 NP 完全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">NP 完全(1)：P, NP 与 NP 完全</span>
        </a>
      
    
      
      
        <a href="/2025/06/12/NP-%E5%AE%8C%E5%85%A8-2-%EF%BC%9A%E5%BD%92%E7%BA%A6%E4%B8%8E%E4%BC%98%E5%8C%96/" title="NP 完全(2)：归约与优化"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">NP 完全(2)：归约与优化</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="分治法"
        id="heading-7fa9794c55018bb18faae2d7c5fa3216" role="tab" data-toggle="collapse" href="#collapse-7fa9794c55018bb18faae2d7c5fa3216"
        aria-expanded="false"
      >
        分治法
        <span class="list-group-count">(5)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-7fa9794c55018bb18faae2d7c5fa3216"
           role="tabpanel" aria-labelledby="heading-7fa9794c55018bb18faae2d7c5fa3216">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/03/11/%E5%88%86%E6%B2%BB%E6%B3%95-1-%EF%BC%9AKaratsuba%E7%AE%97%E6%B3%95%E4%B8%8E%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/" title="分治法(1)：Karatsuba算法与大O表示法"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">分治法(1)：Karatsuba算法与大O表示法</span>
        </a>
      
    
      
      
        <a href="/2025/03/11/%E5%88%86%E6%B2%BB%E6%B3%95-2-%EF%BC%9A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B1%82%E9%80%86%E5%BA%8F%E6%95%B0/" title="分治法(2)：归并排序与求逆序数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">分治法(2)：归并排序与求逆序数</span>
        </a>
      
    
      
      
        <a href="/2025/03/11/%E5%88%86%E6%B2%BB%E6%B3%95-3-%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" title="分治法(3)：快速选择算法"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">分治法(3)：快速选择算法</span>
        </a>
      
    
      
      
        <a href="/2025/03/11/%E5%88%86%E6%B2%BB%E6%B3%95-4-%EF%BC%9A%E6%B1%82%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/" title="分治法(4)：求最近点对"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">分治法(4)：求最近点对</span>
        </a>
      
    
      
      
        <a href="/2025/03/11/%E5%88%86%E6%B2%BB%E6%B3%95-5-%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT/" title="分治法(5)：快速傅立叶变换(FFT)"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">分治法(5)：快速傅立叶变换(FFT)</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="动态规划"
        id="heading-8c05890ac8f93d0195f884f1ff4656ec" role="tab" data-toggle="collapse" href="#collapse-8c05890ac8f93d0195f884f1ff4656ec"
        aria-expanded="false"
      >
        动态规划
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-8c05890ac8f93d0195f884f1ff4656ec"
           role="tabpanel" aria-labelledby="heading-8c05890ac8f93d0195f884f1ff4656ec">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/04/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1-%EF%BC%9ADP%E5%9F%BA%E7%A1%80/" title="动态规划(1)：DP基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">动态规划(1)：DP基础</span>
        </a>
      
    
      
      
        <a href="/2025/04/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2-%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/" title="动态规划(2)：优先级队列优化"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">动态规划(2)：优先级队列优化</span>
        </a>
      
    
      
      
        <a href="/2025/04/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3-%EF%BC%9A%E5%9B%BE%E4%B8%ADDP/" title="动态规划(3)：图中DP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">动态规划(3)：图中DP</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="图"
        id="heading-63db5605ac2d3a21f0abd506c9531209" role="tab" data-toggle="collapse" href="#collapse-63db5605ac2d3a21f0abd506c9531209"
        aria-expanded="false"
      >
        图
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-63db5605ac2d3a21f0abd506c9531209"
           role="tabpanel" aria-labelledby="heading-63db5605ac2d3a21f0abd506c9531209">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/03/11/%E5%9B%BE-1-%EF%BC%9ADFS%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" title="图(1)：DFS及其应用"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">图(1)：DFS及其应用</span>
        </a>
      
    
      
      
        <a href="/2025/03/11/%E5%9B%BE-2-%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-BFS%E4%B8%8EDijkstra/" title="图(2)：最短路径算法(BFS与Dijkstra)"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">图(2)：最短路径算法(BFS与Dijkstra)</span>
        </a>
      
    
      
      
        <a href="/2025/03/27/%E5%9B%BE-3-%EF%BC%9A%E5%90%AB%E8%B4%9F%E8%BE%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/" title="图(3)：含负边的最短路径算法"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">图(3)：含负边的最短路径算法</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="线性规划"
        id="heading-99b79a2373aa97a6cd92cd2d605e3016" role="tab" data-toggle="collapse" href="#collapse-99b79a2373aa97a6cd92cd2d605e3016"
        aria-expanded="false"
      >
        线性规划
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-99b79a2373aa97a6cd92cd2d605e3016"
           role="tabpanel" aria-labelledby="heading-99b79a2373aa97a6cd92cd2d605e3016">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/05/13/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-1-%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/" title="线性规划(1)：线性规划基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">线性规划(1)：线性规划基础</span>
        </a>
      
    
      
      
        <a href="/2025/05/13/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-2-%EF%BC%9ALP%E5%AF%B9%E5%81%B6%E7%9A%84%E5%BA%94%E7%94%A8/" title="线性规划(2)：LP对偶的应用"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">线性规划(2)：LP对偶的应用</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="网络流"
        id="heading-37d59bb9956a274e74173c7babe61ec7" role="tab" data-toggle="collapse" href="#collapse-37d59bb9956a274e74173c7babe61ec7"
        aria-expanded="false"
      >
        网络流
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-37d59bb9956a274e74173c7babe61ec7"
           role="tabpanel" aria-labelledby="heading-37d59bb9956a274e74173c7babe61ec7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/04/22/%E7%BD%91%E7%BB%9C%E6%B5%81-1-%EF%BC%9A%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" title="网络流(1)：算法及其应用"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络流(1)：算法及其应用</span>
        </a>
      
    
      
      
        <a href="/2025/04/25/%E7%BD%91%E7%BB%9C%E6%B5%81-2-%EF%BC%9A%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E/" title="网络流(2)：正确性证明"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络流(2)：正确性证明</span>
        </a>
      
    
      
      
        <a href="/2025/05/01/%E7%BD%91%E7%BB%9C%E6%B5%81-3-%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="网络流(3)：时间复杂度"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络流(3)：时间复杂度</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="贪心算法"
        id="heading-f609d9e1619f07d45b7d493b39e44c77" role="tab" data-toggle="collapse" href="#collapse-f609d9e1619f07d45b7d493b39e44c77"
        aria-expanded="false"
      >
        贪心算法
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-f609d9e1619f07d45b7d493b39e44c77"
           role="tabpanel" aria-labelledby="heading-f609d9e1619f07d45b7d493b39e44c77">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/03/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-1-%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="贪心算法(1)：最小生成树"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">贪心算法(1)：最小生成树</span>
        </a>
      
    
      
      
        <a href="/2025/03/28/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-2-%EF%BC%9A%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%BA%A6/" title="贪心算法(2)：编码与调度"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">贪心算法(2)：编码与调度</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LeetCode 刷题笔记：hot100</h1>
            
              <p id="updated-time" class="note note-default" style="">
                
                  
                    Last updated on February 14, 2026 pm
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>本人的一些 LeetCode 刷题笔记，欢迎参考。</p>
<span id="more"></span>
<h2 id="哈希">哈希</h2>
<p>哈希表的作用是记录之前出现过的内容，C++ 中对应的数据结构有三种：数组、<code>unordered_set</code>、<code>unordered_map</code>。理想情况下，哈希表的插入/删除/查询的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="1-两数之和">1. 两数之和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description">https://leetcode.cn/problems/two-sum/description</a></p>
<p>力扣第一题，非常经典。基本思路是，扫描一遍数组，记录之前扫过的数以及对应的下标，对每个数 <code>nums[i]</code>，查询是否出现过 <code>target - nums[i]</code>，如果有，则返回两个 对应的下标。</p>
<p>要记录之前扫过的数及其下标，就要使用哈希表来存储，查询效率高。同时，由于要存储对应的下标，因此在 C++ 中采用 <code>unordered_map</code> 数据结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; seen;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (seen.<span class="hljs-built_in">find</span>(target - nums[i]) != seen.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;i, seen[target - nums[i]]&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                seen[nums[i]] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>扫描一遍数组，每次操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="2-字母异位词分组">2. 字母异位词分组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/description/">https://leetcode.cn/problems/group-anagrams/description/</a></p>
<p>这题需要将字符串进行分组，分组的标准是：字符串中 26 个字母的出现频次均相同。在扫描所有字符串的过程中，使用一个哈希表存储每一类的字符串。当扫描到一个新的字符串时，检查是否已经有对应的类，如果有则直接加入。</p>
<p>本题的关键在于哈希表的键的设计，这个键需要表征每一组字符串。两个常见的想法是：将排序后的字符串作为键，因为每一类字符串包含的字母相同，排序后形成的字符串一定相同；将出现26个字母的次数作为键。我们这里选择第一种。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; ht;<br>        <span class="hljs-keyword">for</span> (string &amp;str: strs) &#123;<br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br>            ht[key].<span class="hljs-built_in">emplace_back</span>(str);<br>        &#125;<br>        <span class="hljs-comment">// collect result</span><br>        vector&lt;vector&lt;string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it: ht) &#123;<br>            result.<span class="hljs-built_in">emplace_back</span>(it.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>对于每个字符串，需要对字符串进行排序，设字符串最大长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，则时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="3-最长连续序列">3. 最长连续序列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/description">https://leetcode.cn/problems/longest-consecutive-sequence/description</a></p>
<p>这题同样需要记住数组里出现的元素，方便查找，我们使用哈希表。由于不需要记住其他数值，只需要知道一个数是否出现过，我们使用 <code>unordered_set</code>。对于每个数 <code>x</code>，我们依次往后访问 <code>x+1</code>、<code>x+2</code>、…，查询下一个数是否出现，得到序列长度。</p>
<p>但这样时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为对序列中每一个数，都统计了序列长度。事实上，我们只需要对第一个数开始的序列统计长度就可以。因此，在访问每个数 <code>x</code> 时，都判断 <code>x-1</code> 是否在数组中，如果确实存在，则不统计从 <code>x</code> 开始的序列长度。这样，确保了时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，即整个数组只被访问常数次。空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ht</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num: ht) &#123;<br>            <span class="hljs-keyword">if</span> (ht.<span class="hljs-built_in">find</span>(num - <span class="hljs-number">1</span>) != ht.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> curlen = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (ht.<span class="hljs-built_in">find</span>(num + curlen) != ht.<span class="hljs-built_in">end</span>()) curlen++;<br>            maxlen = <span class="hljs-built_in">max</span>(maxlen, curlen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意一个点，遍历数组的时候，应该遍历哈希表，而不是遍历初始数组。初始数组可能包含很多重复元素，遍历可能超时。</p>
<h2 id="双指针">双指针</h2>
<h3 id="4-移动零">4. 移动零</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/">https://leetcode.cn/problems/move-zeroes/description/</a></p>
<p>本题的关键是原地操作，原地操作的核心是避免覆盖有用数据。</p>
<p>本题使用双指针法。定义一个读指针 <code>read</code> 和一个写指针 <code>write</code>，从左到右移动。当读指针读到非 0 数值时，写到写指针的位置。由于写指针所写的位置都已经被读指针读过，不会存在数据覆盖的问题。时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>还有一种方法，就是在读到非 0 数值时，也将两个指针对应的数交换，效果是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> read = <span class="hljs-number">0</span>, write = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (read &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums[read] != <span class="hljs-number">0</span>) &#123;<br>                nums[write++] = nums[read++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                read++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (write &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            nums[write++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="5-盛最多水的容器">5. 盛最多水的容器</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/description/">https://leetcode.cn/problems/container-with-most-water/description/</a></p>
<p>给定两个边界 <code>i</code> 和 <code>j</code>，储存的水量是 <code>min(height[i], height[j]) * (j - i)</code>。我们想要找到一组 <code>(i, j)</code>，使得这个水量最大。这道题有点类似滑动窗口，它存在一个单调性条件。注意到，当给定 <code>(i, j)</code> 时，如果将高度较高的一边向中间移动，水量一定减小。也就是说，我们对于高度较低一边的当前位置，已经不需要再对另一端遍历中间的所有位置了，因为其水量一定全部小于当前水量，这就避免了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的暴力搜索。</p>
<p>综上所述，我们的思路是，将指针初始化在头尾，逐渐向中间移动，记录整个过程中的最大水量。每次的移动方法是，移动高度较低的那一边。时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> maxWater = <span class="hljs-number">0</span>, curWater;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            curWater = <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i);<br>            maxWater = <span class="hljs-built_in">max</span>(maxWater, curWater);<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) i++;<br>            <span class="hljs-keyword">else</span> j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxWater;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="6-三数之和">6. 三数之和</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>
<p>本题的关键是去重。由于返回值不需要包含下标，我们可以首先对数组进行排序，这样更方便去重。</p>
<p>基本思路是：固定三元组中最小的数 <code>nums[i]</code>，将问题转化为在一个数组中找到所有和为 <code>-nums[i]</code> 的二元组，这一步通过双指针实现即可。具体来说，两个指针分别指向 <code>i</code> 右侧数组的首尾，逐渐向中间移动，在过程中收集所有和为 <code>-nums[i]</code> 的去重二元组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j, k, target, curSum;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            target = -nums[i];<br>            j = i + <span class="hljs-number">1</span>; k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                curSum = nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (curSum &lt; target) j++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curSum &gt; target) k--;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j + <span class="hljs-number">1</span>] == nums[j]) j++;<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k - <span class="hljs-number">1</span>] == nums[k]) k--;<br>                    j++; k--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[i + <span class="hljs-number">1</span>] == nums[i]) i++;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（排序）。</p>
<h3 id="7-接雨水">7. 接雨水</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description">https://leetcode.cn/problems/trapping-rain-water/description</a></p>
<p>这道题的思路没有那么直接，我们需要考虑这个雨水的体积究竟如何计算。观察可以发现，从左到右遍历柱子，当出现一个高度为 <code>x</code> 的柱子时，它能决定和左侧每一根“它们之间没有高度超过 <code>x</code> 的柱子”的柱子之间的水量，而这个水量由左侧柱子以及它们之间柱子的最大高度决定。</p>
<p>我们需要维护一个单调栈，存储数组下标，从栈底到栈口，对应的柱子高度单调减小。当扫描到一个新的柱子 <code>k</code> 时，如果栈顶的柱子 <code>j</code> 高度不超过 <code>height[k]</code>，将其弹出并将该高度作为水池的底，假设此时栈顶为 <code>i</code>，那么此时形成水池的高度是 <code>min(height[i], height[k]) - height[j]</code>，宽度是 <code>k - i - 1</code>，如此依次弹出所有高度不超过 <code>height[k]</code> 的柱子，接着将这个新的柱子 <code>j</code> 压入栈中。被弹出的这些柱子已经无法和 <code>k</code> 右侧的柱子一起接住雨水，因为它们被 <code>k</code> 阻挡。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, i, j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; height.<span class="hljs-built_in">size</span>(); k++) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[k] &gt;= height[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                j = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                    i = st.<span class="hljs-built_in">top</span>();<br>                    result += (<span class="hljs-built_in">min</span>(height[i], height[k]) - height[j]) * (k - i - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。这道题也有动态规划和双指针的做法。</p>
<h2 id="滑动窗口">滑动窗口</h2>
<h3 id="8-无重复字符的最长子串">8. 无重复字符的最长子串</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p>
<p>这道题采用滑动窗口的思路，依次向右扩展窗口，如果发现读入的数已经在字符串中出现过，则缩小左侧窗口，直到该字符不重复，记录过程中窗口的最大值，即为答案。可以使用 <code>unordered_set</code> 哈希表来记录当前字符串中有哪些元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; seen;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">length</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (seen.<span class="hljs-built_in">find</span>(s[j]) != seen.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">while</span> (s[i] != s[j]) seen.<span class="hljs-built_in">erase</span>(s[i++]);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                seen.<span class="hljs-built_in">insert</span>(s[j]);<br>            &#125;<br>            result = <span class="hljs-built_in">max</span>(result, j - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|\Sigma|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣Σ∣</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣Σ∣</span></span></span></span> 表示字符集的大小。</p>
<h3 id="9-找到字符串中所有字母异位词">9. 找到字符串中所有字母异位词</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/</a></p>
<p>这道题思路比较直接，因为窗口的大小是固定的，就是 <code>p</code> 的长度。我们只要一格格移动这个窗口，维护好这个窗口中有哪些字母出现（即每个字母出现多少次），是否和 <code>p</code> 中出现的字母完全一致就可以了。可以采取存储差值的方法，当所有差值全为 0 的时候，表明窗口中包含的字符和 <code>p</code> 完全一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() &lt; p.<span class="hljs-built_in">length</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-type">int</span> diff[<span class="hljs-number">26</span>];<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> non_zero = <span class="hljs-number">0</span>, tmp, j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            tmp = ++diff[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">1</span>) non_zero++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) non_zero--;<br>            tmp = --diff[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">-1</span>) non_zero++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) non_zero--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + p.<span class="hljs-built_in">length</span>() &lt;= s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            j = i + p.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                tmp = --diff[s[j] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">-1</span>) non_zero++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) non_zero--;<br>                tmp = ++diff[s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">1</span>) non_zero++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) non_zero--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (non_zero == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|\Sigma|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣Σ∣</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="子串">子串</h2>
<h3 id="10-和为-K-的子数组">10. 和为 K 的子数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">https://leetcode.cn/problems/subarray-sum-equals-k/description/</a></p>
<p>本题可以做一些转化：找和为 <code>k</code> 的子数组，即找起始位置 <code>i</code> 和终止位置 <code>j</code> 使得 <code>nums[i...j]</code> 的和为 <code>k</code>，可以转化为 <code>pre[j] - pre[i - 1] == k</code>，其中 <code>pre[i]</code> 表示 <code>nums[0...i]</code> 中所有数的和。</p>
<p>因此，我们按字串结尾位置遍历数组，假设遍历到 <code>j</code> 位置时，前缀和为 <code>prefix_sum</code>，那么我们就要找到之前是否存在等于 <code>k - prefix_sum</code> 的前缀和，其个数就等于以 <code>j</code> 结尾的和为 <code>k</code> 子数组的个数。而查找之前出现过的前缀和，当然要用哈希表，并且应该记录出现了几次。这样，我们只要遍历一次数组，就可以累加得到和为 <code>k</code> 的子数组的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ht;<br>        ht[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> prefix_sum = <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            prefix_sum += nums[i];<br>            <span class="hljs-keyword">if</span> (ht.<span class="hljs-built_in">count</span>(prefix_sum - k)) result += ht[prefix_sum - k];<br>            ht[prefix_sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="11-滑动窗口最大值">11. 滑动窗口最大值</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">https://leetcode.cn/problems/sliding-window-maximum/description/</a></p>
<p>使用一个双端队列维护可能作为最大值的下标，从左端弹出过期元素（落到窗口外的元素），右端插入刚进入窗口的元素。这个队列是一个单调栈，假如 <code>i</code> 在 <code>j</code> 左侧，即 <code>i &lt; j</code>，则一定有 <code>nums[i] &gt; nums[j]</code>，否则 <code>nums[i]</code> 不可能作为窗口中的最大值。因此，每次插入新元素时，都要弹出右侧比它小的所有元素。队列的最左侧即为当前窗口最大值的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br>            dq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() &lt;= i - k) dq.<span class="hljs-built_in">pop_front</span>();<br>            result.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="12-最小覆盖子串">12. 最小覆盖子串</h3>
<h2 id="普通数组">普通数组</h2>
<h3 id="13-最大子数组和">13. 最大子数组和</h3>
<h3 id="14-合并区间">14. 合并区间</h3>
<h3 id="15-轮转数组">15. 轮转数组</h3>
<h3 id="16-除了自身以外数组的乘积">16. 除了自身以外数组的乘积</h3>
<h3 id="17-缺失的第一个正数">17. 缺失的第一个正数</h3>
<h2 id="矩阵">矩阵</h2>
<h3 id="18-矩阵置零">18. 矩阵置零</h3>
<h3 id="19-螺旋矩阵">19. 螺旋矩阵</h3>
<h3 id="20-旋转图像">20. 旋转图像</h3>
<h3 id="21-搜索二维矩阵-II">21. 搜索二维矩阵 II</h3>
<h2 id="链表">链表</h2>
<h3 id="22-相交链表">22. 相交链表</h3>
<h3 id="23-反转链表">23. 反转链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p>
<p>反转链表是链表的经典题目，采用双指针法，<code>pre</code> 和 <code>cur</code> 指针分别指向前一个和后一个节点，基本过程如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">tmp = cur-&gt;next;<br>cur-&gt;next = pre;<br>pre = cur;<br>cur = tmp;<br></code></pre></td></tr></table></figure>
<p>完整代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode* tmp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="24-回文链表">24. 回文链表</h3>
<h3 id="25-环形链表">25. 环形链表</h3>
<h3 id="26-环形链表-II">26. 环形链表 II</h3>
<h3 id="27-合并两个有序链表">27. 合并两个有序链表</h3>
<h3 id="28-两数相加">28. 两数相加</h3>
<h3 id="29-删除链表的倒数第-N-个结点">29. 删除链表的倒数第 N 个结点</h3>
<h3 id="30-两两交换链表中的节点">30. 两两交换链表中的节点</h3>
<h3 id="31-K-个一组翻转链表">31. K 个一组翻转链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">https://leetcode.cn/problems/reverse-nodes-in-k-group/description/</a></p>
<p>这道题是反转链表的进阶版，主体还是反转链表，不涉及额外的算法，但是加上了链表之间的连接操作，即每一组反转结束后，要将上一组的尾节点 <code>pre_tail</code> 的 <code>next</code> 指针指向这次的头节点。又由于每组的尾节点是反转前的头节点，所以每一组反转前的头节点用 <code>pre_cur</code> 进行保存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">nullptr</span>, *cur = head, *pnr = head;<br>        ListNode *pre_tail = <span class="hljs-literal">nullptr</span>, *pre_cur = <span class="hljs-literal">nullptr</span>, *result = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (pnr) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                <span class="hljs-keyword">if</span> (pnr) pnr = pnr-&gt;next;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    pre_tail-&gt;next = cur;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br>            &#125;<br>            pre_cur = cur;<br>            pre = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">while</span> (cur != pnr) &#123;<br>                ListNode *tmp = cur-&gt;next;<br>                cur-&gt;next = pre;<br>                pre = cur;<br>                cur = tmp;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pre_tail) pre_tail-&gt;next = pre;<br>            <span class="hljs-keyword">else</span> result = pre;<br>            pre_tail = pre_cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="32-随机链表的复制">32. 随机链表的复制</h3>
<h3 id="33-排序链表">33. 排序链表</h3>
<h3 id="34-合并-K-个升序链表">34. 合并 K 个升序链表</h3>
<h3 id="35-LRU-缓存">35. LRU 缓存</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p>
<p>为了实现根据 <code>key</code> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 查找，我们需要使用哈希表。为了实现 LRU 的排队策略，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内从队列中选一个元素排到队尾，我们需要使用链表。但是注意三件事情：</p>
<ul>
<li>为了快速找到节点来完成队列调整，我们在哈希表中应当存放的值是节点指针，而不是 <code>value</code>；</li>
<li>单向链表的节点删除需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间，因为我们需要找到前一个节点，因此我们需要使用双向链表；</li>
<li>为了在逐出节点时同时删去哈希表中的项，在每个节点中我们还需要存放 <code>key</code> 值。</li>
</ul>
<p>我们将队尾设在双向链表的头部，队头设在双向链表的尾部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    DLinkedNode* pre;<br>    DLinkedNode* next;<br><br>    <span class="hljs-built_in">DLinkedNode</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">pre</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value) : <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">pre</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, DLinkedNode*&gt; cache;<br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> cap;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;pre = head;<br>        cap = capacity;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> find_res = cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (find_res == cache.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        DLinkedNode* cur = find_res-&gt;second;<br>        <span class="hljs-comment">// remove node</span><br>        cur-&gt;pre-&gt;next = cur-&gt;next;<br>        cur-&gt;next-&gt;pre = cur-&gt;pre;<br>        <span class="hljs-comment">// add to head</span><br>        cur-&gt;pre = head; cur-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;pre = cur;<br>        head-&gt;next = cur;<br>        <span class="hljs-keyword">return</span> cur-&gt;value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> find_res = cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (find_res != cache.<span class="hljs-built_in">end</span>()) &#123;<br>            DLinkedNode* cur = find_res-&gt;second;<br>            <span class="hljs-comment">// remove node</span><br>            cur-&gt;pre-&gt;next = cur-&gt;next;<br>            cur-&gt;next-&gt;pre = cur-&gt;pre;<br>            <span class="hljs-comment">// add to head</span><br>            cur-&gt;pre = head; cur-&gt;next = head-&gt;next;<br>            head-&gt;next-&gt;pre = cur;<br>            head-&gt;next = cur;<br>            cur-&gt;value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size == cap) &#123;<br>            DLinkedNode* out = tail-&gt;pre;<br>            <span class="hljs-comment">// remove from tail</span><br>            out-&gt;pre-&gt;next = tail;<br>            tail-&gt;pre = out-&gt;pre;<br>            cache.<span class="hljs-built_in">erase</span>(out-&gt;key);<br>            <span class="hljs-keyword">delete</span> out;<br>            size--;<br>        &#125;<br>        size++;<br>        DLinkedNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);<br>        cache.<span class="hljs-built_in">emplace</span>(key, cur);<br>        <span class="hljs-comment">// add to head</span><br>        cur-&gt;pre = head; cur-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;pre = cur;<br>        head-&gt;next = cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度对于 <code>put</code> 和 <code>get</code> 都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mtext>capacity</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\text{capacity})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord text"><span class="mord">capacity</span></span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="二叉树">二叉树</h2>
<h3 id="36-二叉树的中序遍历">36. 二叉树的中序遍历</h3>
<h3 id="37-二叉树的最大深度">37. 二叉树的最大深度</h3>
<h3 id="38-翻转二叉树">38. 翻转二叉树</h3>
<h3 id="39-对称二叉树">39. 对称二叉树</h3>
<h3 id="40-二叉树的直径">40. 二叉树的直径</h3>
<h3 id="41-二叉树的层序遍历">41. 二叉树的层序遍历</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">https://leetcode.cn/problems/binary-tree-level-order-traversal/description/</a></p>
<p>二叉树的层序遍历，属于基本算法，使用一个队列维护要处理的节点。本题需要分开收集每一层的节点，可以用一个 <code>bdth</code> 变量记录每一层的节点数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> bdth = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; nodes;<br>            <span class="hljs-keyword">while</span> (bdth--) &#123;<br>                TreeNode *cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                nodes.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(nodes);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="42-将有序数组转换为二叉搜索树">42. 将有序数组转换为二叉搜索树</h3>
<h3 id="43-验证二叉搜索树">43. 验证二叉搜索树</h3>
<h3 id="44-二叉搜索树中第-K-小的元素">44. 二叉搜索树中第 K 小的元素</h3>
<h3 id="45-二叉树的右视图">45. 二叉树的右视图</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">https://leetcode.cn/problems/binary-tree-right-side-view/description/</a></p>
<p>本题是基于二叉树的层序遍历的，每一层输出最右侧节点即可，也就是队列中最后弹出的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> bdth = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (bdth--) &#123;<br>                TreeNode *cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (bdth == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="46-二叉树展开为链表">46. 二叉树展开为链表</h3>
<h3 id="47-从前序与中序遍历序列构造二叉树">47. 从前序与中序遍历序列构造二叉树</h3>
<h3 id="48-路径总和-III">48. 路径总和 III</h3>
<h3 id="49-二叉树的最近公共祖先">49. 二叉树的最近公共祖先</h3>
<h3 id="50-二叉树中的最大路径和">50. 二叉树中的最大路径和</h3>
<h2 id="图论">图论</h2>
<h3 id="51-岛屿数量">51. 岛屿数量</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">https://leetcode.cn/problems/number-of-islands/description/</a></p>
<p>基础图论题，求连通分量数，用 BFS 或者 DFS 都可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dirs[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inGrid</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">emplace</span>(x, y); visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> i = q.<span class="hljs-built_in">front</span>().first, j = q.<span class="hljs-built_in">front</span>().second; q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dir = <span class="hljs-number">0</span>; dir &lt; <span class="hljs-number">4</span>; dir++) &#123;<br>                <span class="hljs-type">int</span> newx = i + dirs[dir][<span class="hljs-number">0</span>], newy = j + dirs[dir][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">inGrid</span>(newx, newy, m, n) &amp;&amp; grid[newx][newy] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !visited[newx][newy]) &#123;<br>                    q.<span class="hljs-built_in">emplace</span>(newx, newy);<br>                    visited[newx][newy] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> || visited[i][j]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">bfs</span>(grid, visited, m, n, i, j);<br>                result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这里使用 BFS，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\min(m, n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>。</p>
<h3 id="52-腐烂的橘子">52. 腐烂的橘子</h3>
<h3 id="53-课程表">53. 课程表</h3>
<h3 id="54-实现-Trie-前缀树">54. 实现 Trie (前缀树)</h3>
<h2 id="回溯">回溯</h2>
<h3 id="55-全排列">55. 全排列</h3>
<h3 id="56-子集">56. 子集</h3>
<h3 id="57-电话号码的字母组合">57. 电话号码的字母组合</h3>
<h3 id="58-组合总和">58. 组合总和</h3>
<h3 id="59-括号生成">59. 括号生成</h3>
<h3 id="60-单词搜索">60. 单词搜索</h3>
<h3 id="61-分割回文串">61. 分割回文串</h3>
<h3 id="62-N-皇后">62. N 皇后</h3>
<h2 id="二分查找">二分查找</h2>
<h3 id="63-搜索插入位置">63. 搜索插入位置</h3>
<h3 id="64-搜索二维矩阵">64. 搜索二维矩阵</h3>
<h3 id="65-在排序数组中查找元素的第一个和最后一个位置">65. 在排序数组中查找元素的第一个和最后一个位置</h3>
<h3 id="66-搜索旋转排序数组">66. 搜索旋转排序数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">https://leetcode.cn/problems/search-in-rotated-sorted-array/description/</a></p>
<p>这道题的时间要求是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，表明要使用类似二分查找的算法。每次从中间 <code>mid</code> 处将数组分为两半，至少有一个是顺序区间（可以通过左右端点值判断）。通过对比端点数值和 <code>target</code> 的大小，可以确定 <code>target</code> 在哪一半，这样就可以继续二分查找，直到进入顺序区间，采用二分法即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid])  &#123;<br>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>; <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="67-寻找旋转排序数组中的最小值">67. 寻找旋转排序数组中的最小值</h3>
<h3 id="68-寻找两个正序数组的中位数">68. 寻找两个正序数组的中位数</h3>
<h2 id="栈">栈</h2>
<h3 id="69-有效的括号">69. 有效的括号</h3>
<h3 id="70-最小栈">70. 最小栈</h3>
<h3 id="71-字符串解码">71. 字符串解码</h3>
<h3 id="72-每日温度">72. 每日温度</h3>
<h3 id="73-柱状图中最大的矩形">73. 柱状图中最大的矩形</h3>
<h2 id="堆">堆</h2>
<h3 id="74-数组中的第-K-个最大元素">74. 数组中的第 K 个最大元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">https://leetcode.cn/problems/kth-largest-element-in-an-array/description/</a></p>
<p>这道题有两种经典的做法。首先是快速选择算法。选择一个枢轴 <code>pivot</code>，将数组划分为小于 <code>pivot</code> 和大于 <code>pivot</code> 的两个，然后根据 <code>k</code> 的位置选择其中一边，递归操作，直到找到第 <code>k</code> 大的元素。为了让算法性能更好，我们每次随机选择枢轴。划分的具体方法是：使用双指针，一个从左向右扫描，一个从右向左扫描，分别找到第一个左侧大于 <code>pivot</code> 的数和右侧小于 <code>pivot</code> 的数，然后交换，直到两个指针相遇。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx = left + <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[left], nums[idx]);<br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>, j = right;<br>        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt; pivot) i++;<br>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt; pivot) j--;<br>            <span class="hljs-keyword">if</span> (i &lt;= j) <span class="hljs-built_in">swap</span>(nums[i++], nums[j--]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[left], nums[j]);<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> nums[target];<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <span class="hljs-keyword">if</span> (pivot == target) <span class="hljs-keyword">return</span> nums[pivot];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot &lt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, pivot + <span class="hljs-number">1</span>, right, target);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, pivot - <span class="hljs-number">1</span>, target);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, n - k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（递归用栈）。</p>
<p>第二种方法是用堆来做。我们建立一个大小为 <code>k</code> 的小根堆，堆顶元素即为第 <code>k</code> 大的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;heap, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">heapAjust</span>(heap, i, len);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapAjust</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;heap, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        heap[<span class="hljs-number">0</span>] = heap[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= len; j *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; len &amp;&amp; heap[j] &gt; heap[j + <span class="hljs-number">1</span>]) j++;<br>            <span class="hljs-keyword">if</span> (heap[<span class="hljs-number">0</span>] &lt;= heap[j]) <span class="hljs-keyword">break</span>;<br>            heap[i] = heap[j];<br>            i = j;<br>        &#125; <br>        heap[i] = heap[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">heap</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) heap[i] = nums[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">buildHeap</span>(heap, k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; heap[<span class="hljs-number">1</span>]) heap[<span class="hljs-number">1</span>] = nums[i];<br>            <span class="hljs-built_in">heapAjust</span>(heap, <span class="hljs-number">1</span>, k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="75-前-K-个高频元素">75. 前 K 个高频元素</h3>
<h3 id="76-数据流的中位数">76. 数据流的中位数</h3>
<h2 id="贪心算法">贪心算法</h2>
<h3 id="77-买卖股票的最佳时机">77. 买卖股票的最佳时机</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p>
<p>这题比较直观，采用贪心的思路，在最低点买入，最高点卖出。我们只要维护一个过去的最低价格，以及当前能获得的最大利润即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = prices[<span class="hljs-number">0</span>], profit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            profit = <span class="hljs-built_in">max</span>(profit, prices[i] - low);<br>            low = <span class="hljs-built_in">min</span>(low, prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="78-跳跃游戏">78. 跳跃游戏</h3>
<h3 id="79-跳跃游戏-II">79. 跳跃游戏 II</h3>
<h3 id="80-划分字母区间">80. 划分字母区间</h3>
<h2 id="动态规划">动态规划</h2>
<h3 id="81-爬楼梯">81. 爬楼梯</h3>
<h3 id="82-杨辉三角">82. 杨辉三角</h3>
<h3 id="83-打家劫舍">83. 打家劫舍</h3>
<h3 id="84-完全平方数">84. 完全平方数</h3>
<h3 id="85-零钱兑换">85. 零钱兑换</h3>
<h3 id="86-单词拆分">86. 单词拆分</h3>
<h3 id="87-最长递增子序列">87. 最长递增子序列</h3>
<h3 id="88-乘积最大子数组">88. 乘积最大子数组</h3>
<h3 id="89-分割等和子集">89. 分割等和子集</h3>
<h3 id="90-最长有效括号">90. 最长有效括号</h3>
<h2 id="多维动态规划">多维动态规划</h2>
<h3 id="91-不同路径">91. 不同路径</h3>
<h3 id="92-最小路径和">92. 最小路径和</h3>
<h3 id="93-最长回文子串">93. 最长回文子串</h3>
<h3 id="94-最长公共子序列">94. 最长公共子序列</h3>
<h3 id="95-编辑距离">95. 编辑距离</h3>
<h2 id="技巧">技巧</h2>
<h3 id="96-只出现一次的数字">96. 只出现一次的数字</h3>
<h3 id="97-多数元素">97. 多数元素</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/description/">https://leetcode.cn/problems/majority-element/description/</a></p>
<p>这道题比较巧妙的做法是使用摩尔投票法。这个方法基于一个观察：从数组中任意删去两个不同的数，剩下数组的多数元素不变。</p>
<p>因此，我们可以直接选当前的数字作为候选，维护一个计数器，每次出现相等的数字就加 1，出现不同的数字就减 1。如果计数器变为 0，表明前面的元素已经全部抵消，后面数组的多数元素就是整个数组的多数元素，所以只要再次选中当前元素作为候选就可以。最后留下来的候选元素一定就是多数元素，因为它在最后一段中是多数元素，也就在整个数组中是多数元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> candidate, vote = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vote == <span class="hljs-number">0</span>) candidate = nums[i];<br>            <span class="hljs-keyword">if</span> (nums[i] == candidate) vote++;<br>            <span class="hljs-keyword">else</span> vote--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="98-颜色分类">98. 颜色分类</h3>
<h3 id="99-下一个排列">99. 下一个排列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/description/">https://leetcode.cn/problems/next-permutation/description/</a></p>
<p>观察可以发现，求解下一个排列的思路是：从右向左扫描数组，找到第一个下降的数 <code>x</code>，在它右边序列中找出大于 <code>x</code> 的最小的数 <code>y</code>，将这两个数交换位置，再把这一段有序数组反转，就能得到下一个排列。这个思路类似计数的原理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[i]) left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[right]);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="100-寻找重复数">100. 寻找重复数</h3>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
        <a href="/tags/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="print-no-link">#刷题笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LeetCode 刷题笔记：hot100</div>
      <div>https://cny123222.github.io/2026/01/27/LeetCode-刷题笔记：hot100/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Nuoyan Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 27, 2026</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2026/01/28/AI-%E5%85%AB%E8%82%A1-1-%EF%BC%9ABN-LN-RMSNorm/" title="AI 八股(1)：BN, LN, RMSNorm">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">AI 八股(1)：BN, LN, RMSNorm</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2026/01/14/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%9A%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" title="自然语言处理：笔记整理">
                        <span class="hidden-mobile">自然语言处理：笔记整理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"cny123222/cny123222.github.io","repo-id":"R_kgDOOFgnVw","category":"Announcements","category-id":"DIC_kwDOOFgnV84CnwXM","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"en"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
