

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Nuoyan Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="这是《操作系统》SJTU-CS3601 课程的课程笔记系列。本文整理部分为“第 3 部分：进程管理”。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统 SJTU 版(3)：进程管理">
<meta property="og:url" content="https://cny123222.github.io/2025/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-SJTU-%E7%89%88-3-%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Nuoyan Chen&#39;s Blog">
<meta property="og:description" content="这是《操作系统》SJTU-CS3601 课程的课程笔记系列。本文整理部分为“第 3 部分：进程管理”。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cny123222.github.io/img/os-new.png">
<meta property="article:published_time" content="2025-10-24T09:27:09.000Z">
<meta property="article:modified_time" content="2026-01-09T04:55:41.317Z">
<meta property="article:author" content="Nuoyan Chen">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="知识点整理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cny123222.github.io/img/os-new.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>操作系统 SJTU 版(3)：进程管理 - Nuoyan Chen&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"cny123222.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Nuoyan Chen&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/nanjing.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.4)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统 SJTU 版(3)：进程管理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Nuoyan Chen
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-24 17:27" pubdate>
          October 24, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          106 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="操作系统"
        id="heading-30d23ef4f49e85f37f54786ff984032c" role="tab" data-toggle="collapse" href="#collapse-30d23ef4f49e85f37f54786ff984032c"
        aria-expanded="true"
      >
        操作系统
        <span class="list-group-count">(12)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-30d23ef4f49e85f37f54786ff984032c"
           role="tabpanel" aria-labelledby="heading-30d23ef4f49e85f37f54786ff984032c">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2025/10/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-SJTU-%E7%89%88-1-%EF%BC%9A%E6%A6%82%E8%BF%B0/" title="操作系统 SJTU 版(1)：概述"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统 SJTU 版(1)：概述</span>
        </a>
      
    
      
      
        <a href="/2025/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-SJTU-%E7%89%88-2-%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统 SJTU 版(2)：内存管理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统 SJTU 版(2)：内存管理</span>
        </a>
      
    
      
      
        <a href="/2025/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-SJTU-%E7%89%88-3-%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统 SJTU 版(3)：进程管理"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">操作系统 SJTU 版(3)：进程管理</span>
        </a>
      
    
      
      
        <a href="/2025/12/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-SJTU-%E7%89%88-4-%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="操作系统 SJTU 版(4)：文件管理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统 SJTU 版(4)：文件管理</span>
        </a>
      
    
      
      
        <a href="/2025/06/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1-%EF%BC%9A%E6%A6%82%E8%BF%B0/" title="操作系统(1)：概述"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统(1)：概述</span>
        </a>
      
    
      
      
        <a href="/2025/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2-%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86/" title="操作系统(2)：处理机管理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统(2)：处理机管理</span>
        </a>
      
    
      
      
        <a href="/2025/07/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/" title="操作系统(3)：存储器管理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统(3)：存储器管理</span>
        </a>
      
    
      
      
        <a href="/2025/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4-%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="操作系统(4)：文件管理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统(4)：文件管理</span>
        </a>
      
    
      
      
        <a href="/2025/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-%EF%BC%9AI-O%E7%AE%A1%E7%90%86/" title="操作系统(5)：I/O管理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统(5)：I/O管理</span>
        </a>
      
    
      
      
        <a href="/2025/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A2024-%E6%9C%9F%E4%B8%AD%E7%9C%9F%E9%A2%98/" title="操作系统：2024 期中真题"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统：2024 期中真题</span>
        </a>
      
    
      
      
        <a href="/2025/11/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/" title="操作系统：期中复习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统：期中复习</span>
        </a>
      
    
      
      
        <a href="/2025/12/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="操作系统：期末复习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统：期末复习</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统 SJTU 版(3)：进程管理</h1>
            
              <p id="updated-time" class="note note-default" style="">
                
                  
                    Last updated on January 9, 2026 pm
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>这是《操作系统》SJTU-CS3601 课程的课程笔记系列。本文整理部分为“第 3 部分：进程管理”。</p>
<span id="more"></span>
<h2 id="Lecture-9-进程">Lecture 9: 进程</h2>
<ul>
<li><strong>进程的状态数据</strong>：
<ul>
<li>进程标识号（PID）</li>
<li>运行状态：处理器上下文（CPU Context）</li>
<li>地址空间</li>
<li>打开的文件</li>
</ul>
</li>
<li><strong>处理器上下文</strong>：包含恢复进程执行所需要的状态
<ul>
<li>具体包括：PC 寄存器值，栈寄存器值，通用寄存器值，状态寄存器值</li>
</ul>
</li>
</ul>
<h3 id="进程的表示-PCB">进程的表示: PCB</h3>
<ul>
<li><strong>进程</strong>：进程是计算机程序运行时的抽象
<ul>
<li><strong>静态部分</strong>：程序运行需要的代码和数据</li>
<li><strong>动态部分</strong>：程序运行期间的状态（程序计数器、堆、栈等）</li>
</ul>
</li>
<li><strong>进程控制块（PCB）</strong>：每个进程都对应一个元数据，称为“进程控制块” （PCB）
<ul>
<li>进程控制块存储在内核态</li>
<li>进程控制块中包括：独立的虚拟地址空间、独立的处理器上下文、内核栈</li>
</ul>
</li>
<li><strong>内核栈</strong>：
<ul>
<li>进程在内核中依然需要执行代码，有读写临时数据的需求</li>
<li>进程在用户态和内核态的数据应该相互隔离，增强安全性</li>
</ul>
</li>
</ul>
<h3 id="进程的创建">进程的创建</h3>
<ul>
<li><strong>创建和初始化的内容</strong>：
<ul>
<li><strong>用户视角</strong>：代码、数据、堆栈</li>
<li><strong>内核视角</strong>：PCB、虚拟地址空间、上下文、内核栈</li>
</ul>
</li>
</ul>
<p><img src="process_init.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>
<p><strong>一、PCB 相关初始化</strong>：PCB 及其包含的内容都需要创建及初始化</p>
<ul>
<li>分配 PCB 本身的数据结构</li>
<li>初始化 PCB：虚拟内存
<ul>
<li>创建及初始化 vmspace 数据结构</li>
<li>分配一个物理页，作为顶级页表</li>
</ul>
</li>
<li>内核栈：分配物理页，作为进程内核栈</li>
</ul>
</li>
<li>
<p><strong>二、可执行文件加载</strong>：可执行文件通常有固定的存储格式，以 ELF（Executable and Linkable Format）为例</p>
<ul>
<li>从程序头部表可以获取需要的段所在位置</li>
<li>通常只有代码段和数据段需要被加载（loadable）</li>
<li>加载即从 ELF 文件中映射到虚拟地址空间的过程</li>
</ul>
</li>
<li>
<p><strong>三、准备运行环境</strong>：在返回用户态运行前，还需为进程准备运行所需的环境</p>
<ul>
<li>分配用户栈：分配物理内存并映射到虚拟地址空间</li>
<li>准备程序运行时的环境：将参数和环境变量放到栈上</li>
</ul>
</li>
<li>
<p><strong>四、处理器上下文初始化</strong>：最后才初始化处理器上下文，因为其包含的内容直到前序操作完成才确定</p>
<ul>
<li>SP：用户栈分配后才确定地址</li>
<li>PC（保存在 ELR_EL1）：加载 ELF 后才知道入口所在地址</li>
<li>大部分寄存器初始值可直接赋为 0</li>
</ul>
</li>
</ul>
<h3 id="进程的退出与等待">进程的退出与等待</h3>
<ul>
<li><strong>进程退出的实现</strong>：
<ul>
<li>销毁 PCB 及其中保存的所有内容</li>
<li>告知内核，选择其他进程执行</li>
</ul>
</li>
</ul>
<p><img src="process_exit.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>进程等待（<code>process_waitpid</code>）的实现</strong>：
<ul>
<li>为每个进程引入进程标识符（pid），记录在 PCB 中</li>
<li>仍然调用 <code>schedule</code>，让其他进程执行，自己在while循环中等待</li>
<li><strong>改进1</strong>：为进程添加退出状态支持
<ul>
<li>PCB：增加退出状态</li>
<li>process_exit：退出前设置退出状态</li>
</ul>
</li>
<li><strong>改进2</strong>：修改 <code>process_waitpid</code>
<ul>
<li>如果进程已设置为退出，则记录其退出状态并回收</li>
<li>将进程资源的回收操作从 exit 移到了 waitpid</li>
</ul>
</li>
<li><strong>改进3</strong>：限制进程等待的范围（安全性）
<ul>
<li><strong>目标</strong>：只有创建某进程的程序才能监控它</li>
<li><strong>实现</strong>：引入父（创建者）子（被创建者）进程概念
<ul>
<li>进程之间的创建关系构建了一棵进程树，第一个进程（树根）通常由内核主动创建</li>
<li>PCB：维护子进程列表</li>
<li>waitpid：扫描子进程列表而不是所有进程</li>
</ul>
</li>
<li>若父进程不调用 waitpid，则在父进程退出后，由 init 进程代管并回收</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的状态">进程的状态</h3>
<ul>
<li><strong>进程睡眠</strong>：不断查看时间，如果未到规定时间则继续等待</li>
<li><strong>进程的五种典型执行状态</strong>：
<ul>
<li><strong>新生（new）</strong>：刚调用 <code>process_create</code></li>
<li><strong>就绪（ready）</strong>：随时准备执行（但暂时没有执行）</li>
<li><strong>运行（running）</strong>：正在执行</li>
<li><strong>僵尸（zombie）</strong>：退出但未回收</li>
<li><strong>终止（terminated）</strong>：退出且被回收</li>
</ul>
</li>
</ul>
<p><img src="process_states.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>调度</strong>：目的是选出下一个可以执行（就绪）的进程
<ul>
<li>PCB 结构：增加执行状态</li>
<li>调度逻辑片段：只选择状态为 READY 的进程</li>
</ul>
</li>
</ul>
<h3 id="案例分析：LINUX-进程创建">案例分析：LINUX 进程创建</h3>
<ul>
<li>
<p><strong><code>fork()</code> 创建进程</strong>：为调用进程创建一个一模一样的新进程</p>
<ul>
<li>调用进程为父进程，新进程为子进程</li>
<li>接口简单，无需任何参数</li>
<li>fork 后的两个进程均为独立进程
<ul>
<li>拥有不同的进程id</li>
<li>可以并行执行，互不干扰（除非使用特定的接口）</li>
<li>父进程和子进程会共享部分数据结构（内存、文件等）</li>
<li>fork 后父子进程顺序不确定，视调度策略而定</li>
</ul>
</li>
<li>使用 fork 的返回值来分辨父/子进程：
<ul>
<li>0: 子进程</li>
<li>非 0（子进程id）：父进程</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>fork()</code> 的实现</strong>：将父进程的 PCB 拷贝一份</p>
<ul>
<li>包括 PCB、内核栈、处理器上下文等，实现比较简单</li>
</ul>
</li>
<li>
<p><strong><code>fork</code> 的优点</strong>：</p>
<ul>
<li>接口非常简洁，（过去）实现简单</li>
<li>将进程创建和执行（<code>exec</code>）解耦，提高了灵活度</li>
</ul>
</li>
<li>
<p><strong><code>fork</code> 的缺点</strong>：</p>
<ul>
<li>创建拷贝的复杂度与 PCB 复杂度相关（如今越来越复杂）</li>
<li>完全拷贝过于粗暴（不如 <code>clone</code>）</li>
<li>性能差、可扩展性差（不如 <code>vfork</code> 和 <code>spawn</code>）</li>
<li>不可组合性 (如 <code>fork()</code> + <code>pthread()</code>)</li>
</ul>
</li>
<li>
<p><strong><code>fork</code> 的替代接口</strong>：</p>
<ul>
<li><strong><code>vfork</code></strong>：类似于 <code>fork</code>，但让父子进程共享同一地址空间
<ul>
<li><strong>优点</strong>：连映射都不需要拷贝，性能更好</li>
<li><strong>缺点</strong>：只能用在“<code>fork</code> + <code>exec</code>”的场景中；共享地址空间存在安全问题</li>
</ul>
</li>
<li><strong><code>posix_spawn</code></strong>: 相当于 <code>fork</code> + <code>exec</code>
<ul>
<li><strong>优点</strong>：可扩展性、性能较好</li>
<li><strong>缺点</strong>：不如 <code>fork</code> 灵活</li>
</ul>
</li>
<li><strong><code>clone</code></strong>: <code>fork</code> 的进阶版，可以选择性地不拷贝内存
<ul>
<li><strong>优点</strong>：高度可控，可依照需求调整</li>
<li><strong>缺点</strong>：接口比 <code>fork</code> 复杂，选择性拷贝容易出错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程切换">进程切换</h3>
<ul>
<li>
<p><strong>进程切换的基本步骤</strong>：</p>
<ol>
<li>进程1进入内核态</li>
<li>进程1处理器上下文保存</li>
<li>进程上下文切换</li>
<li>进程2处理器上下文恢复</li>
<li>进程2返回用户态</li>
</ol>
</li>
<li>
<p><strong>处理器上下文与进程上下文</strong>：</p>
<ul>
<li><strong>处理器上下文</strong>：用于保存切换时的寄存器状态（<strong>硬件</strong>）
<ul>
<li>在每个 PCB 中均有保存</li>
</ul>
</li>
<li><strong>进程上下文</strong>：表示目前操作系统正以哪个进程的身份运行（<strong>软件</strong>）
<ul>
<li>通常使用一个指向 PCB 的全局指针表示</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>进程切换的节点</strong>：所有调用 <code>schedule()</code> 的地方</p>
<ul>
<li>告知内核选择下一个执行的进程，也就涉及到了进程的切换</li>
</ul>
</li>
<li>
<p><strong>一、p0 进入内核态</strong>：由硬件完成部分寄存器保存</p>
<ul>
<li>PC 和 PSTATE 分别自动保存到 ELR_EL1 和 SPSR_EL1</li>
</ul>
</li>
<li>
<p><strong>二、p0 处理器上下文保存</strong>：将处理器中的寄存器值保存到处理器上下文对应的位置</p>
</li>
<li>
<p><strong>三、由 p0 切换到 p1</strong>：</p>
<ul>
<li><strong>1. 虚拟地址空间切换</strong>：设置页表相关寄存器（TTBR0_EL1）
<ul>
<li>使用 PCB 中保存的页表基地址赋值给 TTBR0_EL1</li>
</ul>
</li>
<li><strong>2. 内核栈切换</strong>：设置内核中的栈寄存器 SP_EL1
<ul>
<li>使用 PCB 中保存的内核栈顶地址赋值给 SP_EL1</li>
</ul>
</li>
<li><strong>3. 进程上下文切换</strong>：设置 <code>cur_proc</code> 为之后要执行的进程（p1）
<ul>
<li>表明之后操作系统将以 p1 的身份运行</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>四、p1 处理器上下文恢复</strong>：从处理器上下文中加载各寄存器的值，放入对应寄存器中</p>
</li>
<li>
<p><strong>五、p1 回到用户态</strong>：由硬件自动恢复部分寄存器</p>
<ul>
<li>将 ELR_EL1 和 SPSR_EL1 中的值自动保存到 PC 和 PSTATE 中</li>
</ul>
</li>
</ul>
<h2 id="Lecture-10-线程">Lecture 10: 线程</h2>
<h3 id="为什么需要线程">为什么需要线程</h3>
<ul>
<li>
<p><strong>进程的问题</strong>：</p>
<ul>
<li><strong>创建进程的开销较大</strong>：包括了数据、代码、堆、栈等</li>
<li><strong>进程的隔离性过强</strong>：进程间交互可以通过进程间通信（IPC），但开销较大</li>
<li><strong>进程内部无法支持并行</strong></li>
</ul>
</li>
<li>
<p><strong>背景</strong>：单台设备计算资源逐渐丰富</p>
<ul>
<li>多核处理器在 21 世纪初逐渐兴起</li>
<li>大型计算机包含大量多核处理器</li>
</ul>
</li>
<li>
<p><strong>简单方法</strong>：进程+调度</p>
<ul>
<li>进程数量一般远超过 CPU 核数</li>
<li>调度器通过分时复用增加计算资源利用率</li>
<li><strong>存在局限</strong>：单一进程无法利用多核资源</li>
<li><strong>解决思路</strong>：用 <code>fork</code> 创建相似进程</li>
</ul>
</li>
<li>
<p><strong>Fork 方法存在的局限</strong>：</p>
<ul>
<li>进程间隔离过强，共享数据困难
<ul>
<li>各进程拥有独立的地址空间，共享需以页为粒度</li>
<li>协调困难，需要复杂的通信机制（如管道）</li>
</ul>
</li>
<li>进程管理开销较大
<ul>
<li>创建：地址空间复制</li>
<li>切换：页表切换</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>解决方案</strong>：使单一进程跨核执行</p>
<ul>
<li><strong>优势</strong>：无需用 <code>fork</code> 创建新进程
<ul>
<li>降低进程管理开销</li>
<li>同一地址空间数据共享/同步方便</li>
</ul>
</li>
<li><strong>需要的支持</strong>：
<ul>
<li>处理器上下文：不同核执行状态不同，需要独立处理器上下文</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程</strong>：更加轻量级的运行时抽象</p>
<ul>
<li>线程<strong>只包含运行时的状态</strong>
<ul>
<li>静态部分由进程提供</li>
<li>包括了执行所需的<strong>最小状态</strong>（主要是寄存器和栈）</li>
</ul>
</li>
<li>一个进程可以包含多个线程
<ul>
<li>多个线程共享同一地址空间（方便数据共享和交互）</li>
<li>允许进程内并行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程的使用：pthread-接口">线程的使用：<code>pthread</code> 接口</h3>
<ul>
<li>
<p><strong>常用库</strong>：POSIX threads（pthreads）</p>
<ul>
<li>实现的功能与进程相关系统调用相似</li>
<li><strong>创建</strong>：<code>pthread_create</code>，创建子线程并获得子线程 id（tid）</li>
<li><strong>回收</strong>：<code>pthread_join</code>，等待 tid 对应线程退出并回收</li>
<li><strong>退出</strong>：<code>pthread_exit</code>，只退出当前线程</li>
<li>一个线程执行系统调用，可能影响该进程的所有线程（如 <code>exit</code> 会使所有线程退出）</li>
</ul>
</li>
<li>
<p><strong>程序控制流分析</strong>：</p>
<ul>
<li>主线程创建子线程后，两线程独立执行</li>
<li>建子线程后，两线程独立执行
<ul>
<li>若主线程先执行，则 <code>exit</code> 被调用，子线程直接被终止</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>基于 <code>join</code> 的方法的问题</strong>： 需要主线程手动调用回收资源</p>
<ul>
<li>若主线程未调用则可能出现资源溢出</li>
<li><strong>解决方案</strong>：加入 <code>detach</code> 操作，调用 <code>detach</code> 可使线程进入“分离”状态
<ul>
<li>分离线程不能被其他线程杀死或回收，退出时资源自动回收</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>pthreads</code> 使用小结</strong>：</p>
<ul>
<li><strong>常用接口</strong>：创建、合并、分离、退出</li>
<li><strong>线程资源默认需要手动回收</strong>：
<ul>
<li>主线程可使用合并（<code>pthread_join</code>）回收其他线程</li>
<li>也可调用分离（<code>pthread_detach</code>）使其他线程自动回收</li>
</ul>
</li>
<li><strong>主线程退出默认会终结所有线程</strong>
<ul>
<li>可改为调用退出（<code>pthread_exit</code>），只退出主线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程">线程</h3>
<ul>
<li>
<p><strong>多线程的进程</strong>：</p>
<ul>
<li>一个进程可以包含多个线程</li>
<li>一个进程的多线程可以在不同处理器上同时执行
<ul>
<li>调度的基本单元由进程变为了线程</li>
<li>每个线程都有自己的执行状态</li>
<li>切换的单位由进程变为了线程</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>多线程进程的地址空间</strong>：</p>
<ul>
<li>每个线程拥有自己的栈</li>
<li>内核中也有为线程准备的内核栈</li>
<li>其它区域共享：数据、代码、堆</li>
</ul>
</li>
</ul>
<p><img src="thread_addr.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>线程与进程的对比</strong>
<ul>
<li><strong>相似之处</strong>：
<ul>
<li>都可以与其他进程/线程并发执行（可能在不同核心上）</li>
<li>都可以进行切换
<ul>
<li>引入线程后，调度管理单位由进程变为线程</li>
</ul>
</li>
</ul>
</li>
<li><strong>不同之处</strong>：
<ul>
<li>同一进程的不同线程共享代码和部分数据
<ul>
<li>不同进程不共享虚拟地址空间</li>
</ul>
</li>
<li>线程与进程相比开销较低
<ul>
<li>进程控制（创建和回收）通常比线程更耗时</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程的实现">线程的实现</h3>
<ul>
<li><strong>线程的表示</strong>：TCB（线程控制块）
<ul>
<li><strong>将 PCB 中部分内容移入 TCB 中</strong>：
<ul>
<li>每个线程 TCB 保存自己的处理器上下文、内核栈、退出/执行状态</li>
<li>进程 PCB 仍维护共享的地址空间</li>
<li>PCB/TCB 间相互引用，便于管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="tcb.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>
<p><strong>内核栈</strong>：除 TCB 外，每个线程也使用独立的内核栈</p>
<ul>
<li>便于各线程在内核中独立执行</li>
</ul>
</li>
<li>
<p><strong>线程创建的实现</strong>：与进程创建相比步骤更少（如不需要加载可执行文件）</p>
</li>
</ul>
<p><img src="thread_init.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>线程退出与合并的实现</strong>：与进程退出/等待的实现类似，线程退出时销毁内容更少（如不需要销毁 vmspace）</li>
</ul>
<p><img src="thread_exit.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>
<p><strong>与进程管理接口的关系</strong>：以 <code>fork</code> 为例，一个多线程的程序调用 <code>fork</code></p>
<ul>
<li><strong>实现方式1</strong>：拷贝父进程中所有的线程</li>
<li><strong>实现方式2</strong>：只拷贝父进程中调用 <code>fork</code> 的线程</li>
<li><strong>POSIX 建议</strong>：尽量避免用 <code>fork</code> 拷贝多线程程序</li>
</ul>
</li>
<li>
<p><strong>用户态线程与内核态线程</strong>：根据线程是否受内核管理，可以将线程分为两类：</p>
<ul>
<li><strong>内核态线程</strong>：内核可见，受内核管理
<ul>
<li>由内核创建，线程相关信息存放在内核中</li>
</ul>
</li>
<li><strong>用户态线程</strong>（纤程）：内核不可见，不受内核直接管理
<ul>
<li>在应用态创建，线程相关信息主要存放在应用数据中</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程模型</strong>：表示了用户态线程与内核态线程之间的联系</p>
<ul>
<li><strong>多对一模型</strong>：多个用户态线程对应一个内核态线程
<ul>
<li><strong>优点</strong>：内核管理简单</li>
<li><strong>缺点</strong>：可扩展性差，无法适应多核机器的发展</li>
<li>在主流操作系统中被弃用</li>
<li>用于各种用户态线程库中</li>
</ul>
</li>
<li><strong>一对一模型</strong>：一个用户态线程对应一个内核态线程
<ul>
<li><strong>优点</strong>：解决了多对一模型中的可扩展性问题</li>
<li><strong>缺点</strong>：内核线程数量大，开销大</li>
<li>主流操作系统都采用一对一模型</li>
</ul>
</li>
<li><strong>多对多模型</strong>：多个用户态线程对应多个内核态线程
<ul>
<li><strong>优点</strong>：解决了可扩展性问题（多对一）和线程过多问题（一对一）</li>
<li><strong>缺点</strong>：管理更为复杂</li>
<li>在虚拟化中得到了广泛应用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="thread_model.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>一对一模型的 TCB</strong>：可以分为两部分
<ul>
<li><strong>内核态</strong>：与 PCB 结构类似，线程切换中会使用</li>
<li><strong>应用态</strong>：可以由线程库定义，可以认为是内核TCB的扩展</li>
</ul>
</li>
</ul>
<h2 id="Lecture-11-处理器调度">Lecture 11: 处理器调度</h2>
<h3 id="处理器调度">处理器调度</h3>
<ul>
<li>
<p><strong>调度的背景</strong>：系统中的任务数远多于处理器数</p>
<ul>
<li><strong>任务（Task）</strong>：线程、单线程进程</li>
</ul>
</li>
<li>
<p><strong>处理器调度</strong>：</p>
<ul>
<li><strong>对象</strong>：CPU 执行的最小单元，可以是进程或线程，统一用“任务”描述</li>
<li><strong>时机</strong>：执行时间用尽；等待 I/O 请求；睡眠；中断；等</li>
<li><strong>决策</strong>：下一个执行的任务；执行该任务的 CPU；执行的时长</li>
</ul>
</li>
<li>
<p><strong>调度</strong>：协调请求对于资源的使用</p>
<ul>
<li><strong>适用的场景</strong>：I/O (磁盘)、打印机、内存、网络包、…</li>
<li><strong>共用的调度指标</strong>：高资源利用率、多任务公平性、低调度开销
<ul>
<li><strong>降低周转时间</strong>：任务第一次进入系统到执行结束的时间</li>
<li><strong>降低响应时间</strong>：任务第一次进入系统到第一次给用户输出的时间</li>
<li><strong>实时性</strong>：在任务的截止时间内完成任务</li>
<li><strong>公平性</strong>：每个任务都应该有机会执行，不能饿死</li>
<li><strong>开销低</strong>：调度器是为了优化系统，而非制造性能 BUG</li>
<li><strong>可扩展</strong>：随着任务数量增加，仍能正常工作</li>
</ul>
</li>
<li><strong>调度的挑战</strong>：
<ul>
<li>缺少信息（没有先知）：工作场景动态变化</li>
<li>任务间的复杂交互</li>
<li>调度目标多样性：不同的系统可能关注不一样的调度指标</li>
<li>许多方面存在取舍</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Linux 中的调度策略</strong>：为了满足不同需求提供多种调度策略</p>
<ul>
<li>以 Linux 两种调度器为例，每种对应多个调度策略：Complete Fair Scheduler (CFS)、Real-Time Scheduler (RT)</li>
</ul>
</li>
</ul>
<h3 id="经典调度-Classical-Scheduling">经典调度 (Classical Scheduling)</h3>
<h4 id="1-先来先得（First-Come-First-Served）">1. 先来先得（First Come First Served）</h4>
<ul>
<li><strong>规则</strong>：按作业或进程到达的先后顺序进行服务</li>
<li><strong>优点</strong>：简单、直观</li>
<li><strong>问题</strong>：平均周转、响应时间过长</li>
</ul>
<h4 id="2-短任务优先（Shortest-Job-First）">2. 短任务优先（Shortest Job First）</h4>
<ul>
<li><strong>规则</strong>：（服务时间）最短的作业或进程优先得到服务</li>
<li><strong>优点</strong>：平均周转时间短</li>
<li><strong>问题</strong>：
<ul>
<li>不公平，长任务饿死</li>
<li>平均响应时间过长</li>
<li>需要预知任务执行时间</li>
</ul>
</li>
</ul>
<h4 id="抢占式调度-Preemptive-Scheduling">抢占式调度 (Preemptive Scheduling)</h4>
<ul>
<li><strong>规则</strong>：每次任务执行一定时间后会被切换到下一任务，而非执行至终止</li>
<li><strong>实现</strong>：通过定时触发的时钟中断实现</li>
</ul>
<h4 id="3-Round-Robin-时间片轮转">3. Round Robin (时间片轮转)</h4>
<ul>
<li><strong>规则</strong>：
<ul>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片</li>
<li>若进程未在一个时间片内执行完，则剥夺 CPU，将进程重新放到就绪队列队尾重新排队</li>
</ul>
</li>
<li><strong>优点</strong>：轮询，公平、平均响应时间短</li>
<li><strong>问题</strong>：
<ul>
<li>牺牲周转时间</li>
<li>时间片过短会导致调度开销过大</li>
</ul>
</li>
<li>
<ul>
<li><strong>时间片大小的影响</strong>：</li>
<li><strong>时间片太大</strong>：退化为 FCFS 算法，会增大进程响应时间</li>
<li><strong>时间片太小</strong>：导致进程切换过于频繁，实际用于进程执行的时间比例减少</li>
</ul>
</li>
</ul>
<h3 id="优先级调度-Priority-Scheduling">优先级调度 (Priority Scheduling)</h3>
<ul>
<li><strong>优先级</strong>：用于确保重要的任务被优先调度
<ul>
<li>操作系统中的任务是不同的</li>
<li>如果不加以区分，系统关键任务无法及时处理</li>
</ul>
</li>
</ul>
<h4 id="4-多级队列-Multi-Level-Queue-MLQ">4. 多级队列 (Multi-Level Queue, MLQ)</h4>
<ul>
<li><strong>规则</strong>：
<ul>
<li>维护多个队列，每个对应静态设置好的优先级</li>
<li>高优先级的任务优先执行</li>
<li>同优先级内使用 Round Robin 调度（也可使用其他调度策略）</li>
</ul>
</li>
<li><strong>问题</strong>：
<ul>
<li>低资源利用率</li>
<li>需要预知任务是否为 I/O 密集型任务</li>
</ul>
</li>
<li><strong>高优先级任务</strong>：
<ul>
<li>I/O 密集型任务：为了更高的资源利用率</li>
<li>用户主动设置的重要任务</li>
<li>时延要求极高（必须在短时间内完成）的任务</li>
</ul>
</li>
<li><strong>Linux Real-Time Scheduler</strong>：使用 Multi-level Queue 优先级调度</li>
<li><strong>优先级的动态调整</strong>：
<ul>
<li>操作系统中的工作场景是动态变化的</li>
<li>静态设置的优先级可能导致：资源利用率低（优先级反转）、低优先级任务饥饿</li>
</ul>
</li>
</ul>
<h4 id="5-多级反馈队列-Multi-Level-Feedback-Queue-MLFQ">5. 多级反馈队列 (Multi-Level Feedback Queue, MLFQ)</h4>
<ul>
<li><strong>目标</strong>：一个无需先验知识的通用调度策略
<ul>
<li>周转时间低、响应时间低</li>
<li>调度开销低</li>
</ul>
</li>
<li><strong>思路</strong>：通过动态分析任务运行历史，总结任务特征
<ul>
<li>类似思想的体现：分支预测、缓存</li>
<li>需要注意：如果工作场景变化频繁，效果会很差</li>
</ul>
</li>
<li><strong>基本规则</strong>：
<ul>
<li>优先级高的任务会抢占优先级低的任务</li>
<li>每个任务会被分配时间片，优先级相同的两个任务使用时间片轮转</li>
<li>任务被创建时，假设该任务是短任务，为它分配最高优先级</li>
<li>一个任务时间片耗尽后，它的优先级会被降低一级</li>
<li>如果一个任务在时间片耗尽前放弃 CPU，那么它的优先级不变
<ul>
<li>任务重新执行时，会被分配新的时间片</li>
</ul>
</li>
</ul>
</li>
<li><strong>案例</strong>：
<ul>
<li>对于长任务：MLFQ 会逐渐降低它的优先级，并将它视为长任务</li>
<li>对于短任务：它会很快执行完，证明自己是个短任务</li>
<li>对于 I/O 密集型任务：它会在时间片执行完以前放弃 CPU，MLFQ 保持它的优先级不变即可</li>
</ul>
</li>
<li><strong>基本规则的问题1</strong>：
<ul>
<li><strong>长任务饥饿</strong>：过多的短任务、I/O 密集型任务可能占用所有 CPU 时间</li>
<li><strong>任务特征可能动态变化</strong>：如 CPU 密集型任务 -&gt; 交互式任务</li>
</ul>
</li>
<li><strong>定时优先级提升</strong>：在某个时间段 S 后，将系统中所有任务优先级升为最高
<ul>
<li><strong>避免长任务饿死</strong>：
<ul>
<li>所有任务的优先级会定时地提升最高</li>
<li>最高级队列采用 RR，长任务一定会被调度到</li>
</ul>
</li>
<li><strong>针对任务特征动态变化的场景</strong>：MLFQ 会定时地重新审视每个任务</li>
</ul>
</li>
<li><strong>基本规则的问题2</strong>：无法应对抢占 CPU 时间的攻击
<ul>
<li>恶意任务在时间片用完前发起 I/O 请求</li>
<li>避免 MLFQ 将该任务的优先级降低，并且每次重新执行时间片会被重置，几乎独占 CPU</li>
</ul>
</li>
<li><strong>更准确地记录执行时间</strong>：一个任务时间片耗尽后（无论它期间放弃了多次 CPU，它的时间片不会被重置），它的优先级会被降低一级
<ul>
<li>MLFQ 会记录每个任务在当前优先级使用的时间片</li>
<li>当累计一个完整时间片被用完后，降低其优先级</li>
</ul>
</li>
<li><strong>MLFQ 的参数调试</strong>：
<ul>
<li>优先级队列的数量、不同队列的时间片长短、定时优先级提升的时间间隔</li>
<li>每个参数都体现了MLFQ的权衡：对于不同的工作场景，不同的参数会导致不一样的表现</li>
</ul>
</li>
<li><strong>MLFQ 各个队列时间片长短的选择</strong>：
<ul>
<li>高优先级队列时间片较短，针对短任务：提升响应时间</li>
<li>低优先级队列时间片较长，针对长任务：降低调度开销</li>
</ul>
</li>
<li><strong>MLFQ 小结</strong>：
<ul>
<li>通过观察任务的历史执行，动态确定任务优先级
<ul>
<li>无需任务的先验知识</li>
</ul>
</li>
<li>同时达到了周转时间和响应时间两方面的要求
<ul>
<li>对于短任务，周转时间指标近似于 SJF</li>
<li>对于交互式任务，响应时间指标近似于 RR</li>
</ul>
</li>
<li>可以避免长任务的饿死</li>
</ul>
</li>
</ul>
<h4 id="6-高响应比优先（Highest-Response-Ratio-Next）">6. 高响应比优先（Highest Response Ratio Next）</h4>
<ul>
<li><strong>规则</strong>：在每次调度时先计算各个任务的响应比，选择响应比最高的任务为其服务</li>
<li><strong>响应比（Response Ratio）</strong>：一个任务的响应时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mtext>Response </mtext></msub></mrow><annotation encoding="application/x-tex">T_\text{Response }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">Response </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 与其运行时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mtext>Run </mtext></msub></mrow><annotation encoding="application/x-tex">T_\text{Run }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">Run </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的比值<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext> 优先级 </mtext><mo>=</mo><mtext> Response Ratio </mtext><mo>=</mo><mfrac><msub><mi>T</mi><mtext>Response </mtext></msub><msub><mi>T</mi><mtext>Run </mtext></msub></mfrac><mo>=</mo><mfrac><mrow><msub><mi>T</mi><mtext>Waiting </mtext></msub><mo>+</mo><msub><mi>T</mi><mtext>Run </mtext></msub></mrow><msub><mi>T</mi><mtext>Run </mtext></msub></mfrac><mo>=</mo><mfrac><msub><mi>T</mi><mtext>Waiting </mtext></msub><msub><mi>T</mi><mtext>Run </mtext></msub></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text { 优先级 }=\text { Response Ratio }=\frac{T_{\text {Response }}}{T_{\text {Run }}}=\frac{T_{\text {Waiting }}+T_{\text {Run }}}{T_{\text {Run }}}=\frac{T_{\text {Waiting }}}{T_{\text {Run }}}+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">优先级</span><span class="mord"> </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord"> Response Ratio </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Run </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Response </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Run </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Waiting </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Run </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Run </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Waiting </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<ul>
<li>如果两个任务等待时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mtext>Waiting </mtext></msub></mrow><annotation encoding="application/x-tex">T_\text{Waiting }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">Waiting </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 相同，则运行时间越短越优先</li>
<li>如果两个任务运行时间相同，则等待时间越长，越优先</li>
</ul>
</li>
<li>HRRN 策略通过结合 FCFS 策略和 SJF 策略，避免了 SJF 策略在公平性方面的问题</li>
</ul>
<h3 id="公平共享调度-Fair-Share-Scheduling">公平共享调度 (Fair-Share Scheduling)</h3>
<ul>
<li><strong>公平共享</strong>：
<ul>
<li>每个用户占用的资源是成比例的，而非被任务的数量决定</li>
<li>每个用户占用的资源是可以被计算的，设定“份额”以确定相对比例</li>
</ul>
</li>
<li><strong>方法</strong>：使用 ticket 表示任务的份额
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>：ticket 的总量</li>
</ul>
</li>
</ul>
<h4 id="7-彩票调度-Lottery-Scheduling">7. 彩票调度 (Lottery Scheduling)</h4>
<ul>
<li><strong>规则</strong>：
<ul>
<li>每次调度时，生成随机数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R \in [0,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></li>
<li>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，找到对应的任务</li>
</ul>
</li>
<li><strong>彩票转让（Ticket Transfer）</strong>：
<ul>
<li>场景：在通信过程中，客户端需要等到服务端返回才能继续执行</li>
<li>客户端将自己所有的 ticket 转让给服务端
<ul>
<li>确保服务端可以尽可能使用更多资源，迅速处理</li>
</ul>
</li>
<li>同样适用于其他需要同步的场景</li>
</ul>
</li>
<li><strong>份额与优先级的异同</strong>：
<ul>
<li>份额影响任务对 CPU 的占用比例，不会有任务饿死</li>
<li>优先级影响任务对 CPU 的使用顺序，可能产生饿死</li>
</ul>
</li>
<li><strong>随机的利弊</strong>：
<ul>
<li><strong>好处</strong>：简单</li>
<li><strong>问题</strong>：不精确，伪随机非真随机；各个任务对 CPU 时间的占比会有误差</li>
</ul>
</li>
</ul>
<h4 id="8-步幅调度-Stride-Scheduling">8. 步幅调度 (Stride Scheduling)</h4>
<ul>
<li>确定性版本的 Lottery Scheduling</li>
<li><strong>Stride</strong>：步幅，任务一次执行增加的虚拟时间<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext> stride </mtext><mo>=</mo><mfrac><mtext> MaxStride </mtext><mtext> ticket </mtext></mfrac></mrow><annotation encoding="application/x-tex">\text { stride }=\frac{\text { MaxStride }}{\text { ticket }}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord"> stride </span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> ticket </span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> MaxStride </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> MaxStride </mtext></mrow><annotation encoding="application/x-tex">\text{ MaxStride }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord"> MaxStride </span></span></span></span></span> 是一个足够大的整数</li>
</ul>
</li>
<li><strong>Pass</strong>：累计执行的虚拟时间</li>
<li><strong>规则</strong>：每次调度时，挑选 Pass 最小的任务</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Lottery Scheduling</th>
<th style="text-align:center">Stride Scheduling</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">调度决策生成</td>
<td style="text-align:center">随机</td>
<td style="text-align:center">确定性计算</td>
</tr>
<tr>
<td style="text-align:center">任务实际执行时间与预期的差距</td>
<td style="text-align:center">大</td>
<td style="text-align:center">小</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>Linux Complete Fair Scheduler</strong>：通过调整任务每次执行的时间，达成公平共享的方式</p>
</li>
<li>
<p><strong>虚拟时间对调度行为的影响</strong>：</p>
<ul>
<li><strong>虚拟时间的意义</strong>：
<ul>
<li>相对大小：对应了任务的优先级</li>
<li>绝对值：对应了任务预期占用 CPU 的时间长度</li>
</ul>
</li>
<li><strong>问题</strong>：如果新创建/刚被唤醒的任务 vruntime 很小，会立即长时间占用 CPU</li>
<li><strong>解决方案</strong>
<ul>
<li>维护所有任务虚拟时间的最小值 min_vruntime</li>
<li>当任务被创建、唤醒时，保证任务的 vruntime 不小于 min_vruntime</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多核调度策略-Multicore-Scheduling-Policy">多核调度策略 (Multicore Scheduling Policy)</h3>
<ul>
<li>
<p><strong>需要考虑的额外因素</strong>：一个进程的不同线程可以在不同 CPU 上同时运行</p>
</li>
<li>
<p><strong>全局运行队列</strong>：</p>
<ul>
<li><strong>规则</strong>：所有 CPU 共享同一个全局运行队列</li>
<li><strong>问题</strong>：
<ul>
<li>所有 CPU 竞争全局调度器</li>
<li>同一个线程可能在不同 CPU 上切换
<ul>
<li>切换开销大：Cache、TLB、…</li>
<li>缓存局部性差</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>本地运行队列</strong>：每个 CPU 核心维护本地运行队列</p>
<ul>
<li>现被应用于 Linux、ChCore 等操作系统中</li>
<li><strong>问题</strong>：负载不均衡</li>
</ul>
</li>
<li>
<p><strong>负载均衡</strong>：尽可能让每个 CPU 都同等忙碌</p>
<ul>
<li>需要追踪 CPU 的负载情况</li>
<li>将任务从负载高的 CPU 迁移到负载低的 CPU</li>
</ul>
</li>
<li>
<p><strong>亲和性</strong>：尽量让一个进程调度到同一个 CPU 上运行，以发挥 CPU 中 Cache 的作用</p>
<ul>
<li>通过操作系统暴露的任务亲和性接口，可以指定任务能够使用的 CPU 核心</li>
</ul>
</li>
</ul>
<h2 id="Lecture-12-进程间通信">Lecture 12: 进程间通信</h2>
<ul>
<li>
<p><strong>IPC (Inter-Process Communication)</strong>：进程与进程间的通信方式</p>
<ul>
<li><strong>必要性</strong>：不同进程拥有不同的内存地址空间，进程与进程之间无法直接进行通信和交互</li>
</ul>
</li>
<li>
<p><strong>常见 IPC 的类型</strong></p>
</li>
</ul>
<p><img src="ipc.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="简单-IPC-的设计与实现">简单 IPC 的设计与实现</h3>
<ul>
<li><strong>简单 IPC 的消息接口</strong>：
<ul>
<li>发送消息：<code>Send(message)</code></li>
<li>接收消息：<code>Recv(message)</code></li>
<li>远程方法调用：<code>RPC(req_message, resp_message)</code></li>
<li>远程方法调用的回复：<code>Reply(resp_message)</code></li>
</ul>
</li>
<li><strong>简单 IPC 的两个阶段</strong>：
<ul>
<li><strong>阶段1</strong>：准备阶段
<ul>
<li>建立通信连接，即进程间的信道
<ul>
<li>假设内核已经为两个进程映射了一段共享内存</li>
</ul>
</li>
</ul>
</li>
<li><strong>阶段2</strong>：通信阶段
<ul>
<li>数据传递
<ul>
<li>“消息”抽象：通常包含头部和数据内容（不能传指针）</li>
</ul>
</li>
<li>通信机制
<ul>
<li>两个消息保存在共享内存中：发送者消息、接收者消息</li>
<li>发送者和接收者通过轮询消息的状态作为通知机制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>简单 IPC 数据传递的两种方法</strong>：
<ul>
<li><strong>方法1</strong>：基于共享内存的数据传递
<ul>
<li>操作系统在通信过程中不干预数据传输</li>
<li>操作系统仅负责准备阶段的映射</li>
<li><strong>优势</strong>：
<ul>
<li>无需切换到内核态即可完成 IPC（多核场景下）</li>
<li>完全由用户态控制，定制能力更强</li>
<li>可实现零内存拷贝（无需内核介入）</li>
</ul>
</li>
</ul>
</li>
<li><strong>方法2</strong>：基于操作系统辅助的数据传递
<ul>
<li>操作系统提供接口（系统调用）：Send、Recv</li>
<li>通过内核态内存来传递数据，无需在用户态建立共享内存</li>
<li><strong>优势</strong>：
<ul>
<li>抽象更简单，用户态直接调用接口，使用更方便</li>
<li>安全性保证更强，发送者在消息被接收时通常无法修改消息</li>
<li>多方（多进程）通信时更灵活、更安全</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>简单 IPC 的通知机制</strong>：
<ul>
<li><strong>方法1</strong>：基于轮询（消息头部的状态信息）
<ul>
<li><strong>缺点</strong>：大量 CPU 计算资源的浪费</li>
</ul>
</li>
<li><strong>方法2</strong>：基于控制流转移
<ul>
<li>由内核控制进程的运行状态</li>
<li><strong>优点</strong>：进程只有在条件满足的情况下才运行，避免 CPU 浪费</li>
</ul>
</li>
</ul>
</li>
<li><strong>IPC 控制流</strong>：同步和异步
<ul>
<li><strong>同步 IPC</strong>：IPC 操作会阻塞进程直到操作完成
<ul>
<li>线性的控制流</li>
<li>调用者继续运行时，返回结果已经 ready</li>
</ul>
</li>
<li><strong>异步 IPC</strong>：进程发起 IPC 操作后即可返回而不需要等待其完成
<ul>
<li>通过轮询或回调函数（需内核支持）来获取返回结果</li>
</ul>
</li>
</ul>
</li>
<li><strong>IPC 的超时机制</strong>：
<ul>
<li><strong>超时可能的原因</strong>：
<ul>
<li>被调用者是恶意的：故意不返回</li>
<li>被调用者不是恶意的：运行时间过长、调度时间过长、请求丢失等</li>
</ul>
</li>
<li><strong>超时机制</strong>：
<ul>
<li>应用可自行设置超时的阈值，但如何选择合适的阈值却很难</li>
<li>特殊的超时机制：阻塞、立即返回（要求被调用者处于可立即响应的状态）</li>
</ul>
</li>
</ul>
</li>
<li><strong>IPC 的权限检查</strong>：
<ul>
<li><strong>宏内核</strong>：通常基于权限检查的机制实现
<ul>
<li>如 Linux 中与文件的权限检查结合在一起</li>
</ul>
</li>
<li><strong>微内核</strong>：通常基于 Capability 安全检查机制实现
<ul>
<li>Capability 保存在内核中，与进程绑定</li>
<li>进程发起 IPC 时，内核检查其是否拥有对应的 Capability</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="ipc2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="共享内存-内存接口的-IPC">共享内存 (内存接口的 IPC)</h3>
<ul>
<li><strong>基础实现</strong>：
<ul>
<li><strong>共享区域</strong>：共享区域容量、共享状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  . . .<br>&#125; item;<br>item buffer[BUFFER_SIZE];<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> buffer_write_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> buffer_read_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> empty_slot = BUFFER_SIZE;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> filled_slot = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>发送者(生产者)</strong>：当没有新消息时，接收者盲目等待</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (new_package) &#123;<br>  <span class="hljs-comment">/* Produce an item/msg */</span><br>  <span class="hljs-keyword">while</span> (empty_slot == <span class="hljs-number">0</span>)<br>    ;   <span class="hljs-comment">/* do nothing -- no free buffers */</span><br>  empty_slot --;<br>  buffer[buffer_write_cnt] = msg;<br>  buffer_write_cnt = (buffer_write_cnt + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>  filled_slot ++; <br>  …<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>接收者</strong>：当没有新消息时，接收者盲目等待</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (wait_package) &#123;<br>  <span class="hljs-keyword">while</span> (filled_slot == <span class="hljs-number">0</span>)<br>    ; <span class="hljs-comment">// do nothing -- nothing to consume</span><br>  filled_slot--; <span class="hljs-comment">// remove an item from the buffer</span><br>  item = buffer[buffer_read_cnt];<br>  buffer_read_cnt = (buffer_read_cnt + <span class="hljs-number">1</span>) % BUFFER SIZE;<br>  empty_slot++;<br>  <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>共享内存的问题</strong>：
<ul>
<li><strong>缺少通知机制</strong>：
<ul>
<li>若轮询检查，则导致 CPU 资源浪费</li>
<li>若周期性检查，则可能导致较长的等待时延</li>
<li><strong>根本原因</strong>：共享内存的抽象过于底层；缺少 OS 更多支持</li>
</ul>
</li>
<li><strong>TOCTTOU （Time-of-check to Time-of-use）问题</strong>：
<ul>
<li>当接收者直接用共享内存上的数据时，可能存在被发送者恶意篡改的情况（发生在接收者检查完数据之后，使用数据之前）</li>
<li>这可能导致 buffer overflow 等问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="消息传递（Message-Passing）">消息传递（Message Passing）</h3>
<ul>
<li><strong>消息队列</strong>：消息队列是间接消息传递方式，通过共享一个队列来建立连接
<ul>
<li>以链表的方式组织消息</li>
<li>任何有权限的进程都可以访问队列，写入或者读取</li>
<li>支持异步通信 (非阻塞)</li>
</ul>
</li>
<li><strong>消息的格式</strong>：类型 + 数据</li>
<li><strong>消息队列的组织</strong>：
<ul>
<li>基本遵循 FIFO 先进先出原则</li>
<li><strong>消息队列的写入</strong>：增加在队列尾部</li>
<li><strong>消息队列的读取</strong>：默认从队首获取消息</li>
</ul>
</li>
<li>允许按照类型查询: <code>Recv(A, type, message)</code>
<ul>
<li>如 <code>type</code> 为正数，则返回第一个类型为 <code>type</code> 的消息</li>
</ul>
</li>
</ul>
<h3 id="轻量级远程方法调用-LRPC">轻量级远程方法调用 (LRPC)</h3>
<ul>
<li><strong>LRPC 解决的问题</strong>：
<ul>
<li><strong>控制流转换</strong>：Client 进程快速通知 Server 进程</li>
<li><strong>数据传输</strong>：将栈和寄存器参数传递给 Server 进程</li>
</ul>
</li>
<li><strong>控制流转换</strong>：调度导致不确定时延
<ul>
<li>控制流转换需要下陷到内核</li>
<li>内核系统为了保证公平等，会在内核中根据情况进行调度
<ul>
<li>Client 和 Server 之间可能会执行多个不相关进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>迁移线程</strong>：将 Client 运行在 Server 的上下文
<ul>
<li>使用 Server 的代码和数据，使用 Server 的权限 (如访问某些系统资源)</li>
<li>只切换地址空间、权限表等状态，不做调度和线程切换</li>
</ul>
</li>
<li><strong>数据传输</strong>：数据拷贝的性能损失
<ul>
<li>大部分 Unix 类系统，经过内核的传输有(至少)两次拷贝 (Client -&gt; 内核 -&gt; Server)</li>
<li>数据拷贝：慢（拷贝本身的性能就不快）；不可扩展（数据量增大，时延增大）</li>
</ul>
</li>
<li><strong>共享参数栈和寄存器</strong>：
<ul>
<li><strong>参数栈 (A-stack)</strong>：
<ul>
<li>系统内核为每一对 LRPC 连接预先分配好一个 A-stack</li>
<li>A-stack 被同时映射在 Client 进程和 Server 进程地址空间</li>
<li>Client 进程只需要将参数准备到 A-stack 即可，不需要内核额外拷贝</li>
</ul>
</li>
<li><strong>执行栈 (E-stack)</strong></li>
<li><strong>共享寄存器</strong>：
<ul>
<li><strong>普通的上下文切换</strong>：保存当前寄存器状态 -&gt; 恢复切换到的进程寄存器状态</li>
<li><strong>LRPC 迁移进程</strong>：直接使用当前的通用寄存器，类似函数调用中用寄存器传递参数</li>
</ul>
</li>
</ul>
</li>
<li><strong>通信连接建立</strong>：
<ul>
<li>Server 进程通过内核注册一个服务描述符
<ul>
<li>对应 Server 进程内部的一个处理函数</li>
</ul>
</li>
<li>内核为服务描述符预先分配好参数栈</li>
<li>内核为服务描述符分配好调用记录，用于从 Server 进程处返回（类似栈）</li>
<li>内核将参数栈交给 Client 进程，作为一个绑定成功的标志
<ul>
<li>在通信过程中，通过检查 A-stack 来判断 Client 是否正确发起通信</li>
</ul>
</li>
</ul>
</li>
<li><strong>一次调用过程</strong>：
<ol>
<li>内核验证绑定对象的正确性，并找到正确的服务描述符</li>
<li>内核验证参数栈和连接记录</li>
<li>检查是否有并发调用 (可能导致 A-stack 等异常)</li>
<li>将 Client 的返回地址和栈指针放到连接记录中</li>
<li>将连接记录放到线程控制结构体中的栈上 (支持嵌套 LRPC 调用)</li>
<li>找到 Server 进程的 E-stack (执行代码所使用的栈)</li>
<li>将当前线程的栈指针设置为 Server 进程的运行栈地址</li>
<li>将地址空间切换到 Server 进程中</li>
<li>执行 Server 地址空间中的处理函数</li>
</ol>
</li>
</ul>
<h3 id="Binder-IPC">Binder IPC</h3>
<ul>
<li><strong>Binder IPC</strong>：兼具IPC数据传输的高性能与高安全
<ul>
<li>框架层 Binder 服务框架：发现服务，接口封装</li>
<li>内核层 Binder 驱动：提供内核层 IPC 能力</li>
</ul>
</li>
<li><strong>Binder IPC 数据传输</strong>：通过内存映射减少 IPC数据拷贝
<ul>
<li>发送端一次数据拷贝，接受端零次数据拷贝</li>
</ul>
</li>
<li><strong>数据序列化</strong>：
<ul>
<li><strong>问题</strong>：复杂数据结构无法直接跨进程传输
<ul>
<li>数据结构嵌套</li>
<li>指针、文件描述符等接收端无法访问</li>
</ul>
</li>
<li><strong>方案</strong>：序列化与反序列化
<ul>
<li>序列化：将数据结构展开为一个字节串</li>
<li>反序列化：将字节串转换为原有数据结构</li>
</ul>
</li>
</ul>
</li>
<li><strong>Binder IPC 数据序列化</strong>：内核辅助完成特殊对象传输
<ul>
<li>文件描述符、句柄等</li>
<li>定位特殊对象位置 + 帮助接收端进程重构特殊对象</li>
</ul>
</li>
<li><strong>服务端线程数量</strong>：
<ul>
<li>IPC 请求需要服务端线程的处理：一个 IPC Server 可能处理大量 Client 请求</li>
<li>少量服务线程 -&gt; 无法应对高负载任务</li>
<li>大量服务线程 -&gt; 低负载时浪费资源</li>
</ul>
</li>
<li><strong>Binder IPC 线程池模型</strong>：
<ul>
<li>服务端设置最大线程数量</li>
<li>内核动态创建服务线程：默认从服务线程池挑选处理线程，服务线程不足自动创建</li>
</ul>
</li>
</ul>
<h2 id="Lecture-13-同步原语">Lecture 13: 同步原语</h2>
<h3 id="并发带来的同步问题：竞争条件">并发带来的同步问题：竞争条件</h3>
<ul>
<li><strong>竞争条件</strong>：
<ul>
<li>当 2 个或以上线程同时对共享的数据进行操作，其中至少有一个写操作</li>
<li>该共享数据最后的结果依赖于这些线程特定的执行顺序</li>
</ul>
</li>
</ul>
<h3 id="生产者消费者与多生产者消费者">生产者消费者与多生产者消费者</h3>
<ul>
<li><strong>临界区（Critical Section）</strong>：任意时刻，有且只有一个线程可以进入临界区执行</li>
<li><strong>实现临界区抽象的三个要求</strong>：
<ul>
<li><strong>互斥访问</strong>：在同一时刻，有且仅有一个线程可以进入临界区</li>
<li><strong>有限等待</strong>：当一个线程申请进入临界区之后，必须在有限的时间内获得许可进入临界区而不能无限等待</li>
<li><strong>空闲让进</strong>：当没有线程在临界区中时，必须在申请进入临界区的线程中选择一个进入临界区，保证执行临界区的进展</li>
</ul>
</li>
<li><strong>同步原语（Synchronization Primitives）</strong>：一个平台（如操作系统）提供的用于帮助开发者实现线程之间同步的软件工具
<ul>
<li>在有限的共享资源上正确的协同工作</li>
</ul>
</li>
</ul>
<h3 id="互斥锁">互斥锁</h3>
<ul>
<li><strong>互斥锁（Mutual Exclusive Lock）接口</strong>：保证同时只有一个线程能够拿到锁
<ul>
<li><code>Lock(lock)</code>：尝试拿到锁 <code>lock</code>
<ul>
<li>若当前没有其他线程拿着 lock，则拿到 lock，并继续往下执行</li>
<li>若 lock 被其他线程拿着，则不断循环等待放锁（busy loop）</li>
</ul>
</li>
<li><code>Unlock(lock)</code>：释放锁</li>
</ul>
</li>
</ul>
<h3 id="条件变量">条件变量</h3>
<ul>
<li><strong>条件变量</strong>：利用睡眠/唤醒机制，避免无意义的等待
<ul>
<li>让操作系统的调度器调度其他进程/线程执行</li>
</ul>
</li>
<li><strong>等待的接口</strong>：<code>void cond_wait(struct cond *cond, struct lock *mutex);</code>
<ol>
<li>放入条件变量的等待队列</li>
<li>阻塞自己同时释放锁：即调度器可以调度到其他线程</li>
<li>被唤醒后重新获取锁</li>
</ol>
</li>
<li><strong>唤醒的接口</strong>：<code>void cond_signal(struct cond *cond);</code>
<ol>
<li>检查等待队列</li>
<li>如果有等待者则移出等待队列并唤醒</li>
</ol>
</li>
</ul>
<h3 id="信号量（Semaphore）">信号量（Semaphore）</h3>
<ul>
<li><strong>信号量 （PV 原语）</strong>：协调（阻塞/放行）多个线程共享有限数量的资源
<ul>
<li>语义上：信号量的值 cnt 记录了当前可用资源的数量</li>
<li>提供了两个原语 P 和 V 用于等待/消耗资源</li>
<li>P 操作：消耗资源</li>
<li>V 操作：增加资源</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>	new_msg = produce_new(); 	<br>  sem_wait(&amp;empty_slot_sem);  <span class="hljs-comment">// 消耗empty_slot</span><br>	buffer_add(new_msg); 	<br>  sem_signal(&amp;filled_slot_sem);  <span class="hljs-comment">// 增加filled_slot</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>	sem_wait(&amp;filled_slot_sem);  <span class="hljs-comment">// 消耗filled_slot</span><br>	cur_msg = buffer_remove(); 	<br>  sem_signal(&amp;empty_slot_sem);  <span class="hljs-comment">// 增加empty_slot</span><br>  handle_msg(cur_msg);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>二元信号量</strong>：初始化的资源数量为 1
<ul>
<li>其计数器（counter）只有可能为 0、1 两个值</li>
<li>同一时刻只有一个线程能够拿到资源</li>
</ul>
</li>
<li><strong>计数信号量</strong>：初始化的资源数量大于 1
<ul>
<li>同一时刻可能有多个线程能够拿到资源</li>
</ul>
</li>
</ul>
<h3 id="读写锁">读写锁</h3>
<ul>
<li><strong>互斥锁</strong>：所有的线程均互斥，同一时刻只能有一个线程进入临界区
<ul>
<li>对于部分只读取共享数据的线程过于严厉</li>
</ul>
</li>
<li><strong>读写锁</strong>：区分读者与写者，允许读者之间并行，读者与写者之间互斥</li>
</ul>
<p><img src="read_write.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="不同同步原语之间的比较">不同同步原语之间的比较</h3>
<ul>
<li><strong>互斥锁/条件变量/信号量</strong>：
<ul>
<li><strong>互斥锁</strong>与<strong>二元信号量</strong>功能类似，但抽象不同：
<ul>
<li>互斥锁有拥有者的概念，一般同一个线程拿锁/放锁</li>
<li>信号量为资源协调，一般一个线程 signal，另一个线程 wait</li>
</ul>
</li>
<li><strong>条件变量</strong>用于解决不同问题（睡眠/唤醒），需要搭配<strong>互斥锁</strong>使用
<ul>
<li>搭配<strong>互斥锁+计数器</strong>可以实现与<strong>信号量</strong>相同的功能</li>
</ul>
</li>
</ul>
</li>
<li><strong>互斥锁 vs 读写锁</strong>：
<ul>
<li>接口不同：读写锁区分读者与写者</li>
<li>针对场景不同：获取更多程序语义，标明只读代码段，达到更好性能</li>
<li>读写锁在读多写少场景中可以显著提升读者并行度，即允许多个读者同时执行读临界区</li>
<li>只用写者锁，则与互斥锁的语义基本相同</li>
</ul>
</li>
</ul>
<h3 id="同步带来的问题：死锁">同步带来的问题：死锁</h3>
<ul>
<li><strong>死锁产生的原因</strong>：
<ul>
<li><strong>互斥访问</strong>：同一时刻只有一个线程能够访问</li>
<li><strong>持有并等待</strong>：一直持有一部分资源并等待另一部分，不会中途释放</li>
<li><strong>资源非抢占</strong>：即 proc_B 不会抢 proc_A 已经持有的锁 A</li>
<li><strong>循环等待</strong>：存在一种进程资源的循环等待链（A 等 B，B 等 A）</li>
</ul>
</li>
<li><strong>死锁的处理策略</strong>：
<ul>
<li><strong>死锁检测与恢复</strong>：允许死锁发生，系统负责检测出死锁并解除（出问题再处理）</li>
<li><strong>避免死锁</strong>：避免系统进入不安全状态（设计时避免）</li>
<li><strong>预防死锁</strong>：破坏死锁产生的四个必要条件（运行时避免）</li>
</ul>
</li>
</ul>
<h4 id="死锁的检测与恢复">死锁的检测与恢复</h4>
<ul>
<li><strong>资源分配图</strong>：
<ul>
<li><strong>两种结点</strong>：
<ul>
<li><strong>进程结点</strong>：对应一个进程</li>
<li><strong>资源结点</strong>：对应一类资源，一类资源可能有多个</li>
</ul>
</li>
<li><strong>两种边</strong>：
<ul>
<li><strong>资源节点 --&gt; 进程结点（分配边）</strong>：表示已经为进程分配了几个资源（每条边代表一个）</li>
<li><strong>进程结点 --&gt; 资源结点（请求边）</strong>：表示进程想还申请几个资源（每条边代表一个）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="deadlock-detection.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>死锁的检测</strong>：在资源分配图中找到环（循环等待）</li>
<li><strong>死锁的恢复</strong>：
<ul>
<li>直接 kill 所有循环中的线程</li>
<li>Kill 一个，看有没有环，有的话继续 kill</li>
<li>全部回滚到之前的某一状态</li>
</ul>
</li>
</ul>
<h4 id="死锁预防">死锁预防</h4>
<ul>
<li><strong>避免互斥访问</strong>：通过其他手段，如代理执行
<ul>
<li>只有代理线程能够访问共享资源，避免数据竞争</li>
<li>发送修改请求，由代理线程统一执行</li>
</ul>
</li>
<li><strong>不允许持有并等待</strong>：一次性申请所有资源
<ul>
<li><code>trylock</code>：非阻塞，立即返回成功或失败</li>
<li>无法获取 B，那么释放 A</li>
<li>带来的活锁 Live Lock：死锁是无法恢复的，但是活锁可能自己恢复</li>
</ul>
</li>
<li><strong>资源允许抢占</strong>：需要考虑如何恢复
<ul>
<li>要让线程 A 正确回滚到拿锁 A 之前的状态</li>
</ul>
</li>
<li><strong>打破循环等待</strong>：按照特定顺序获取资源
<ul>
<li>对所有资源进行编号，让所有线程递增获取</li>
<li>任意时刻，获取最大资源号的线程可以继续执行，然后释放资源</li>
</ul>
</li>
</ul>
<h4 id="死锁避免">死锁避免</h4>
<ul>
<li><strong>死锁避免</strong>：运行时检查是否会出现死锁</li>
<li><strong>银行家算法</strong>：
<ul>
<li>所有线程获取资源需要通过管理者同意</li>
<li>管理者预演会不会造成死锁
<ul>
<li>如果会造成：阻塞线程，下次再给</li>
<li>如果不会造成：给线程该资源</li>
</ul>
</li>
</ul>
</li>
<li><strong>安全状态与非安全状态</strong>：
<ul>
<li><strong>安全状态</strong>：能找出至少一个执行序列，如P2-&gt;P1-&gt;P5…，让所有线程需求得到满足</li>
<li><strong>非安全状态</strong>：不能找出这个序列，必定会导致死锁</li>
<li>银行家算法通过安全性检查算法，保证系统一直处于安全状态，且按照这个序列执行</li>
</ul>
</li>
<li><strong>安全性检查</strong>：
<ul>
<li><strong>四个数据结构</strong>：<code>M</code> 个资源，<code>N</code> 个线程
<ul>
<li>全局可利用资源：<code>Available[M]</code></li>
<li>每线程最大需求量：<code>Max[N][M]</code></li>
<li>已分配资源：<code>Allocation[N][M]</code></li>
<li>还需要的资源：<code>Need[N][M]</code></li>
</ul>
</li>
<li><strong>检查步骤</strong>：
<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Lecture-14-同步原语的实现">Lecture 14: 同步原语的实现</h2>
<h3 id="互斥锁实现：基于硬件原子指令">互斥锁实现：基于硬件原子指令</h3>
<ul>
<li><strong>互斥锁的 naive 实现</strong>：
<ul>
<li>操作-1：读 <code>L</code>，检查状态是否为 <code>Locked</code></li>
<li>操作-2：写 <code>L</code>，将其状态设置为 <code>Locked</code></li>
<li><strong>问题</strong>：两个线程同时拿到锁</li>
<li><strong>根本原因</strong>：这两步并非原子完成</li>
<li><strong>硬件方法</strong>：用<strong>原子指令</strong>来保证两步是原子的</li>
</ul>
</li>
<li><strong>使用 <code>Test-and-Set</code> 指令实现互斥锁</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> *old_ptr, <span class="hljs-type">int</span> new)</span> &#123;<br>  <span class="hljs-type">int</span> old = *old_ptr; <span class="hljs-comment">// fetch old value at old_ptr</span><br>  *old_ptr = new; <span class="hljs-comment">// store &#x27;new&#x27; into old_ptr</span><br>  <span class="hljs-keyword">return</span> old; <span class="hljs-comment">// return the old value</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">lock_t</span> &#123;</span><br>  <span class="hljs-type">int</span> flag;<br>&#125; <span class="hljs-type">lock_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  <span class="hljs-comment">// 0 indicates that lock is available, 1 that it is held</span><br>  lock-&gt;flag = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  <span class="hljs-keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>  ; <span class="hljs-comment">// spin-wait (do nothing)</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>使用 <code>Compare-and-swap</code> 指令实现互斥锁</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">CompareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> new)</span> &#123;<br>  <span class="hljs-type">int</span> actual = *ptr;<br>  <span class="hljs-keyword">if</span> (actual == expected)<br>    *ptr = new;<br>  <span class="hljs-keyword">return</span> actual;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  <span class="hljs-keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>  ; <span class="hljs-comment">// spin-wait (do nothing)</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>使用 <code>Load-linked</code> &amp; <code>Store-conditional</code> 指令实现互斥锁</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LoadLinked</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span> &#123;<br>  <span class="hljs-keyword">return</span> *ptr;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">StoreConditional</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> value)</span> &#123;<br>  <span class="hljs-keyword">if</span> (no one has updated *ptr since the LoadLinked to this address) &#123;<br>    *ptr = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// success!</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// failed to update</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) == <span class="hljs-number">1</span>)<br>    ; <span class="hljs-comment">// spin until it&#x27;s zero</span><br>    <span class="hljs-keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// if set-it-to-1 was a success: all done</span><br>              <span class="hljs-comment">// otherwise: try it all over again</span><br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>使用 <code>Fetch-and-add</code> 指令实现互斥锁</strong>：
<ul>
<li><strong>排号锁（Ticket Lock）</strong>：通过遵循竞争者到达的顺序来传递锁</li>
<li><strong><code>owner</code></strong>：表示当前的持有者</li>
<li><strong><code>next</code></strong>：表示目前放号的最新值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">FetchAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span> &#123;<br>  <span class="hljs-type">int</span> old = *ptr;<br>  *ptr = old + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">lock_t</span> &#123;</span><br>  <span class="hljs-type">int</span> ticket;<br>  <span class="hljs-type">int</span> turn;<br>&#125; <span class="hljs-type">lock_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  lock-&gt;ticket = <span class="hljs-number">0</span>;<br>  lock-&gt;turn = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  <span class="hljs-type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);<br>  <span class="hljs-keyword">while</span> (lock-&gt;turn != myturn)<br>  ; <span class="hljs-comment">// spin</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span> &#123;<br>  lock-&gt;turn = lock-&gt;turn + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="条件变量的实现">条件变量的实现</h3>
<ul>
<li><strong>条件变量的实现（语义级）</strong>：需要操作系统辅助实现
<ul>
<li><strong>等待的接口</strong>：<code>void wait(struct cond *cond, struct lock *mutex);</code>
<ol>
<li>放入条件变量的等待队列：<code>list_append(cond-&gt;wait_list, proc_self()); </code></li>
<li>阻塞自己同时释放锁：<code>unlock(mutex), yield()</code></li>
<li>被唤醒后重新获取锁：<code>lock(mutex);</code></li>
</ol>
</li>
<li><strong>唤醒的接口</strong>：<code>void signal(struct cond *cond);</code>
<ol>
<li>检查等待队列：<code>if (!list_empty(cond-&gt;wait_list))</code></li>
<li>如果有等待者则移出等待队列并唤醒：<code>wakeup(list_remove(cond-&gt;wait_list));</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="条件变量的基础：YIELD">条件变量的基础：<code>YIELD()</code></h4>
<ul>
<li><strong>系统调用 yield()</strong>：进程调用 <code>yield()</code>，主动放弃 CPU，进入可运行队列等待，类似 <code>sleep</code></li>
<li><strong><code>yield()</code> 的具体步骤</strong>：
<ul>
<li>暂停当前运行的线程：保存上下文</li>
<li>选择新的可运行线程：例如通过 round-robin 找到下一个 RUNNABLE 线程</li>
<li>恢复上一步所选线程：重新加载该线程的状态</li>
</ul>
</li>
<li><strong>三个数据结构</strong>：
<ul>
<li><code>threads table</code>：记录所有线程的表</li>
<li><code>t_lock</code>：即 threads table lock，用于保护 threads table</li>
<li><code>CPUs table</code>：记录每个 CPU 当前运行线程（注意这个表没有用 lock 保护）</li>
</ul>
</li>
<li><strong><code>YIELD()</code> 实现</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">yield():<br>  lock(t_lock)<br><br>  <span class="hljs-comment">// 暂停运行的线程</span><br>  id = cpus[CPU].thread<br>  <span class="hljs-keyword">if</span> (id == null) <span class="hljs-keyword">return</span><br>  threads[id].state = RUNNABLE<br>  threads[id].sp = SP<br><br>  <span class="hljs-comment">// 选择新线程</span><br>  <span class="hljs-keyword">do</span>:<br>    id = (id + <span class="hljs-number">1</span>) mod N<br>  <span class="hljs-keyword">while</span> threads[id].state != RUNNABLE<br><br>  <span class="hljs-comment">// 恢复新线程运行</span><br>  SP = threads[id].sp<br>  threads[id].state = RUNNING<br>  cpus[CPU].thread = id<br>  <br>  unlock(t_lock)<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>t_lock</strong>：
<ul>
<li>原子性地设置 <code>threads[ ].state</code> 和 <code>.sp</code></li>
<li>原子性地找到一个 <code>RUNNABLE</code> 的线程，并改为 <code>RUNNING</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="条件变量的实现：wait-Signal">条件变量的实现：<code>wait</code> &amp; <code>Signal</code></h4>
<ul>
<li><strong>Lost Notification 问题</strong>：</li>
</ul>
<p><img src="lost_noti.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>带锁参数的 API</strong>：<code>WAIT(bb.full, bb.lock)</code></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">send</span><span class="hljs-params">(bb, msg)</span></span>:<br>  <span class="hljs-built_in">lock</span>(bb.lock)<br>  while True:<br>    <span class="hljs-keyword">if</span> bb<span class="hljs-selector-class">.in</span> - bb<span class="hljs-selector-class">.out</span> &lt; N:<br>      bb<span class="hljs-selector-class">.buf</span><span class="hljs-selector-attr">[bb.in mod N]</span> &lt;- msg<br>      bb<span class="hljs-selector-class">.in</span> &lt;- bb<span class="hljs-selector-class">.in</span> + <span class="hljs-number">1</span><br>      <span class="hljs-built_in">unlock</span>(bb.lock)<br>      <span class="hljs-built_in">signal</span>(bb.not_empty)<br>      return<br>  <span class="hljs-built_in">wait</span>(bb<span class="hljs-selector-class">.not_full</span>, bb.lock)<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><strong><code>WAIT</code></strong>：</p>
<ul>
<li>使用 <code>t_lock</code> 来保证放 <code>lock</code> 和 <code>yield</code> 的原子性</li>
<li>注意：<code>t_lock</code> 和 <code>lock</code> 的顺序很重要</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">wait(cv, lock):<br>  disable_interrupt()<br>  lock(t_lock)<br>  unlock(lock)<br>  threads[id].cv = cv<br>  threads[id].state = WAITING<br>  yield_wait()<br>  unlock(t_lock)<br>  enable_interrupt()<br>  lock(lock)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>SIGNAL</code></strong>：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">signal(cv):<br>  lock(t_lock)<br>  <span class="hljs-keyword">for</span> I = <span class="hljs-number">0</span> to N<span class="hljs-number">-1</span>:<br>    <span class="hljs-keyword">if</span> threads[i].cv == cv &amp;&amp; threads[i].state == WAITING:<br>      threads[i].state = RUNNABLE<br>  unlock(t_lock)<br></code></pre></td></tr></table></figure>
<ul>
<li><strong><code>YIELD_WAIT()</code></strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">yield_wait(): <span class="hljs-comment">// called by wait()</span><br>  id = cpus[CPU].thread<br>  <span class="hljs-comment">// 防止时钟中断导致当前 thread 无法被唤醒</span><br>  cpus[CPU].thread = null<br>  threads[id].sp = SP<br>  <span class="hljs-comment">// 防止多个 CPU 的 SP 同时指向这个栈，导致栈被破坏</span><br>  SP = cpus[CPU].<span class="hljs-built_in">stack</span><br><br>  <span class="hljs-keyword">do</span>:<br>    id = (id + <span class="hljs-number">1</span>) mod N<br>    <span class="hljs-comment">// 防止当前 threads[] 中没有一个 RUNNABLE 的线程，导致死锁</span><br>    unlock(t_lock)<br>    <span class="hljs-comment">// 防止此时发生时钟中断，导致死锁</span><br>    enable_interrupt()<br>    disable_interrupt()<br>    lock(t_lock)<br>  <span class="hljs-keyword">while</span> threads[id].state != RUNNABLE<br><br>  SP = threads[id].sp<br>  threads[id].state = RUNNING<br>  cpus[CPU].thread = id<br></code></pre></td></tr></table></figure>
<h3 id="信号量的实现">信号量的实现</h3>
<ul>
<li><strong>信号量的语义</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> &#123;<br>	<span class="hljs-keyword">while</span>(S &lt;= <span class="hljs-number">0</span>)<br>		<span class="hljs-comment">/* Waiting */</span>;<br>	<span class="hljs-type">atomic_add</span>(&amp;S, <span class="hljs-number">-1</span>); <br>&#125; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> S)</span> &#123;<br>	<span class="hljs-type">atomic_add</span>(&amp;S, <span class="hljs-number">1</span>); <br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>信号量的实现</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *S)</span> &#123;<br>  lock(S-&gt;sem_lock);<br>  S-&gt;value --;<br>  <span class="hljs-keyword">if</span> (S-&gt;value &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>      cond_wait(S-&gt;sem_cond, S-&gt;sem_lock);<br>    &#125; <span class="hljs-keyword">while</span> (S-&gt;wakeup == <span class="hljs-number">0</span>);<br>    S-&gt;wakeup --;<br>  &#125;<br>  unlock(S-&gt;sem_lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *S)</span> &#123;<br>  lock(S-&gt;sem_lock);<br>  S-&gt;value ++;<br>  <span class="hljs-keyword">if</span> (S-&gt;value &lt;= <span class="hljs-number">0</span>) &#123;<br>    S-&gt;wakeup ++;<br>    cond_signal(S-&gt;sem_cond);                <br>  &#125;<br>  unlock(S-&gt;sem_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>实现说明</strong>：
<ul>
<li><code>wakeup</code>：等待时可以唤醒的数量</li>
<li>某一时刻真实的资源数：<code>value &lt; 0 ? wakeup : value + wakeup</code></li>
</ul>
</li>
</ul>
<h3 id="读写锁的实现">读写锁的实现</h3>
<ul>
<li>
<p><strong>读写锁的偏向性</strong>：有读者在临界区，有新的写者在等待，另一个读者能否进入临界区</p>
<ul>
<li><strong>不能（偏向写者的读写锁）</strong>；后序读者必须等待写者进入后才进入；更加公平</li>
<li><strong>能（偏向读者的读写锁）</strong>：后序读者可以直接进入临界区；更好的并行性</li>
</ul>
</li>
<li>
<p><strong>偏向读者的读写锁的实现</strong>：</p>
</li>
</ul>
<p><img src="read-write.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><strong>实现说明</strong>：
<ul>
<li><code>reader</code> 计数器：表示有多少读者</li>
<li>第一个/最后一个 reader 负责获取/释放写锁</li>
<li>只有当完全没有读者时，写者才能进入临界区</li>
</ul>
</li>
</ul>
<h3 id="不同同步原语之间的比较-2">不同同步原语之间的比较</h3>
<p><img src="comp.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>
<p><strong>互斥锁 vs 读写锁</strong>：</p>
<ul>
<li>读写锁为特定场景（衍生场景一）下提升读者并行度</li>
<li>衍生场景一直接使用互斥锁，也可以保证正确性，读者之间不能并发执行</li>
<li>特定场景下的性能优化</li>
</ul>
</li>
<li>
<p><strong>互斥锁 vs 条件变量</strong>：</p>
<ul>
<li>解决不同场景（正交）：
<ul>
<li>互斥锁：互斥访问</li>
<li>条件变量：条件等待与唤醒</li>
</ul>
</li>
<li>条件变量需要搭配互斥锁使用</li>
<li>互斥锁中也可以使用条件变量避免循环等待
<ul>
<li>场景一中也可能包含场景二的需求</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>互斥锁 vs 信号量</strong>：</p>
<ul>
<li><strong>互斥锁与二元信号量</strong>：
<ul>
<li>功能基本一致，二元信号量可以实现互斥</li>
<li>语义差别：二元信号量可以由不同的线程获取/释放；互斥锁语义上只能由同一个线程获取与释放</li>
<li>保护资源互斥场景，推荐使用互斥锁（方便优化）</li>
</ul>
</li>
<li><strong>互斥锁与计数信号量</strong>：应对不同场景
<ul>
<li>互斥锁控制对唯一资源的互斥访问（即临界区）</li>
<li>计数信号量控制多个线程对多个资源的获取与释放</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>条件变量 vs 信号量</strong>：</p>
<ul>
<li>提供了类似的接口</li>
<li>抽象层级的区别
<ul>
<li>条件变量：更底层，提供睡眠唤醒机制；适用范围更广</li>
<li>信号量：针对具体的场景（提供对有限资源的管理）；可以使用条件变量+互斥锁+计数器实现信号量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="同步原语案例分析">同步原语案例分析</h3>
<h4 id="同步案例1：多线程执行屏障">同步案例1：多线程执行屏障</h4>
<ul>
<li>多线程执行屏障，等待全部执行到屏障后再继续执行</li>
<li>符合场景2：线程等待/唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">lock(&amp;thread_cnt_lock);<br>thread_cnt--;<br><span class="hljs-keyword">if</span> (thread_cnt == <span class="hljs-number">0</span>)<br>  cond_broadcast(cond);<br><span class="hljs-keyword">while</span>(thread_cnt != <span class="hljs-number">0</span>)<br>  cond_wait(&amp;cond, &amp;thread_cnt_lock); <br>unlock(&amp;thread_cnt_lock);<br></code></pre></td></tr></table></figure>
<h4 id="同步案例2：等待队列工作窃取">同步案例2：等待队列工作窃取</h4>
<ul>
<li>每核心等待队列，在空时允许窃取其他核心的任务</li>
<li>符合场景1：共享资源互斥访问</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">lock(ready_queue_lock[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure>
<h4 id="同步案例-3：map-reduce">同步案例-3：map-reduce</h4>
<ul>
<li>
<p>Word-count：大文本拆分字数统计</p>
<ul>
<li>Mapper：统计一部分文本自述</li>
<li>Reducer：一旦其中任意数量的 Mapper 结束，就累加其结果</li>
</ul>
</li>
<li>
<p>符合场景2：线程等待/唤醒</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mapper</span><br>lock(&amp;finished_cnt_lock);<br>finished_cnt ++;<br>cond_signal(&amp;cond); <br>unlock(&amp;finished_cnt_lock);<br><br><span class="hljs-comment">// Reducer</span><br>lock(&amp;finished_cnt_lock);<br><span class="hljs-keyword">while</span>(finished_cnt == <span class="hljs-number">0</span>)<br>  cond_wait(&amp;cond, &amp;finished_cnt_lock);<br><span class="hljs-comment">/* collect result */</span><br>finished_cnt = <span class="hljs-number">0</span>;<br>unlock(&amp;finished_cnt_lock);<br></code></pre></td></tr></table></figure>
<ul>
<li>也符合场景3：将 Mapper 的结果视为资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mapper</span><br>signal(&amp;finish_sem);<br><br><span class="hljs-comment">// Reducer</span><br><span class="hljs-keyword">while</span>(finished_cnt != mapper_cnt) &#123;<br>  wait(&amp;finish_sem);<br>  <span class="hljs-comment">/* collect result */</span><br>  finished_cnt ++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="同步案例4：网页渲染">同步案例4：网页渲染</h4>
<ul>
<li>网页等待所有的请求均完成后再进行渲染</li>
<li>场景2：等待/唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Request_cb</span><br>lock(&amp;glock);<br>finished_cnt ++；<br><span class="hljs-keyword">if</span> (finished_cnt == req_cnt)<br>  cond_signal(&amp;gcond);<br>unlock(&amp;glock);<br><br><span class="hljs-comment">// 渲染线程</span><br>lock(&amp;glock);<br><span class="hljs-keyword">while</span> (finished_cnt != req_cnt)<br>  cond_wait(&amp;gcond, &amp;glock);<br>unlock(&amp;glock);<br></code></pre></td></tr></table></figure>
<ul>
<li>场景3：视为所有请求结果为资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Request_cb</span><br>signal(&amp;gsem);<br><br><span class="hljs-comment">// 渲染线程</span><br><span class="hljs-keyword">while</span>(remain_req != <span class="hljs-number">0</span>) &#123;<br>  wait(&amp;gsem);<br>  remain_req --;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="同步案例5：线程池并发控制">同步案例5：线程池并发控制</h4>
<ul>
<li>控制同一时刻可以执行的线程数量（有的线程阻塞时可以允许新的线程替上）
<ul>
<li>例如，允许同时三个线程执行</li>
</ul>
</li>
<li>场景3：视剩余可并行执行线程数量为有限资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">thread_routine () &#123;<br>  wait(&amp;thread_cnt_sem);<br>  <span class="hljs-comment">/* doing something */</span><br>  signal(&amp;thread_cnt_sem);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="同步案例6：网页服务器">同步案例6：网页服务器</h4>
<ul>
<li>处理响应客户端获取静态网页需求，处理后端更新静态网页需求，不允许读取更新到一半的页面</li>
<li>衍生场景1：读写场景，可以使用读写锁
<ul>
<li>client 用读锁，后端用写锁</li>
</ul>
</li>
</ul>
<p><img src="selection.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="参考资料">参考资料</h2>
<p>本文参考上海交通大学并行与分布式系统研究所（IPADS）操作系统课程 CS3601 华志超老师的 PPT 课件整理。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
        <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="print-no-link">#课程笔记</a>
      
        <a href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="print-no-link">#知识点整理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统 SJTU 版(3)：进程管理</div>
      <div>https://cny123222.github.io/2025/10/24/操作系统-SJTU-版-3-：进程管理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Nuoyan Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>October 24, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/28/Paper-Reading-7-DIMES/" title="Paper Reading #7: DIMES">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Paper Reading #7: DIMES</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-SJTU-%E7%89%88-2-%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统 SJTU 版(2)：内存管理">
                        <span class="hidden-mobile">操作系统 SJTU 版(2)：内存管理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"cny123222/cny123222.github.io","repo-id":"R_kgDOOFgnVw","category":"Announcements","category-id":"DIC_kwDOOFgnV84CnwXM","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"en"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  




  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
